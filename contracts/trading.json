{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "module": "trading",
  "version": "1.0.0",
  "description": "Trading engine interface contracts / 交易引擎接口契约",
  "owner": "Agent ARCH",
  "last_updated": "2025-12-01",
  "last_updated_by": "Agent ARCH",
  "last_updated_by": "Agent ARCH",
  "readonly_for": ["Agent TRADING", "Agent PORTFOLIO", "Agent WEB", "Agent AI", "Agent QA"],
  "interfaces": {
    "ExchangeClient": {
      "description": "Base exchange client interface / 交易所客户端基础接口",
      "methods": {
        "__init__": {
          "description": "Initialize exchange client with API credentials",
          "params": {
            "api_key": "string (optional)",
            "api_secret": "string (optional)",
            "testnet": "boolean (optional)"
          },
          "returns": "void",
          "raises": []
        },
        "set_symbol": {
          "description": "Update the trading symbol",
          "params": {
            "symbol": "string"
          },
          "returns": "boolean",
          "raises": ["SymbolNotFoundError"]
        },
        "get_leverage": {
          "description": "Get current leverage for the symbol",
          "params": {},
          "returns": "integer",
          "raises": ["ConnectionError"]
        },
        "set_leverage": {
          "description": "Set leverage for the symbol",
          "params": {
            "leverage": "integer"
          },
          "returns": "boolean",
          "raises": ["ConnectionError", "InvalidLeverageError"]
        },
        "get_max_leverage": {
          "description": "Get maximum leverage for the symbol",
          "params": {},
          "returns": "integer",
          "raises": ["ConnectionError"]
        },
        "get_symbol_limits": {
          "description": "Get trading limits for the symbol",
          "params": {},
          "returns": {
            "minQty": "float",
            "maxQty": "float",
            "stepSize": "float",
            "minNotional": "float"
          },
          "raises": []
        },
        "fetch_market_data": {
          "description": "Fetch current market data (order book, mid price, tick/step sizes)",
          "params": {},
          "returns": {
            "best_bid": "float",
            "best_ask": "float",
            "mid_price": "float",
            "timestamp": "integer",
            "tick_size": "float",
            "step_size": "float"
          },
          "raises": ["ConnectionError", "SymbolNotFoundError"]
        },
        "fetch_funding_rate": {
          "description": "Fetch funding rate for current symbol",
          "params": {},
          "returns": "float",
          "raises": ["ConnectionError"]
        },
        "fetch_funding_rate_for_symbol": {
          "description": "Fetch funding rate for specific symbol",
          "params": {
            "symbol": "string"
          },
          "returns": "float",
          "raises": ["ConnectionError", "SymbolNotFoundError"]
        },
        "fetch_bulk_funding_rates": {
          "description": "Fetch funding rates for multiple symbols",
          "params": {
            "symbols": "array of string"
          },
          "returns": "dict[string, float]",
          "raises": ["ConnectionError"]
        },
        "fetch_ticker_stats": {
          "description": "Fetch 24h ticker statistics",
          "params": {},
          "returns": {
            "percentage": "float",
            "quoteVolume": "float"
          },
          "raises": ["ConnectionError"]
        },
        "fetch_account_data": {
          "description": "Fetch position and balance data for current symbol (primary method for account information)",
          "params": {},
          "returns": {
            "position_amt": "float",
            "entry_price": "float",
            "balance": "float",
            "available_balance": "float",
            "liquidation_price": "float"
          },
          "raises": ["ConnectionError"],
          "notes": "This method returns account data for the current symbol set via set_symbol(). For multi-symbol position support, use fetch_positions(). Balance information is in balance and available_balance fields."
        },
        "fetch_balance": {
          "description": "Fetch account balance and margin information",
          "params": {},
          "returns": {
            "total": "float (total balance in USDT)",
            "available": "float (available balance in USDT)",
            "margin_used": "float (margin used in USDT)",
            "margin_available": "float (margin available in USDT)",
            "margin_ratio": "float (margin ratio as percentage, 0-100)",
            "liquidation_price": "float (liquidation price if applicable)"
          },
          "raises": ["ConnectionError"],
          "notes": "Returns balance and margin information in USDT. Can be extracted from fetch_account_data() or fetched separately for clarity."
        },
        "fetch_positions": {
          "description": "Fetch all open positions across all symbols (multi-symbol support)",
          "params": {},
          "returns": "array of Position objects",
          "raises": ["ConnectionError"],
          "notes": "Returns all open positions for all symbols. Each Position object contains symbol, side, size, entry_price, mark_price, unrealized_pnl, etc. Required for AC-2 and AC-7 (multi-symbol position support)."
        },
        "fetch_position": {
          "description": "Fetch position for specific symbol",
          "params": {
            "symbol": "string (optional, defaults to current symbol)"
          },
          "returns": {
            "symbol": "string",
            "side": "string (LONG|SHORT|NONE)",
            "size": "float",
            "entry_price": "float",
            "mark_price": "float",
            "unrealized_pnl": "float",
            "liquidation_price": "float",
            "timestamp": "integer"
          },
          "raises": ["ConnectionError", "SymbolNotFoundError"],
          "notes": "Returns position details for a specific symbol. If symbol is not provided, returns position for current symbol. Required for AC-2 (position tracking)."
        },
        "fetch_position_history": {
          "description": "Fetch position history (both open and closed positions)",
          "params": {
            "limit": "integer (optional, default: 100)",
            "start_time": "integer (optional, timestamp in milliseconds)",
            "symbol": "string (optional, filter by symbol)"
          },
          "returns": "array of PositionHistory objects",
          "raises": ["ConnectionError"],
          "notes": "Returns historical positions with timestamps. Each PositionHistory object includes open_time, close_time (if closed), entry_price, exit_price, realized_pnl, etc. Required for AC-5 (position history)."
        },
        "fetch_open_orders": {
          "description": "Fetch all open orders for the symbol",
          "params": {},
          "returns": "array of Order objects",
          "raises": ["ConnectionError"]
        },
        "fetch_order": {
          "description": "Fetch order status by order ID",
          "params": {
            "order_id": "string"
          },
          "returns": {
            "order_id": "string",
            "symbol": "string",
            "side": "string (BUY|SELL)",
            "type": "string (LIMIT|MARKET)",
            "quantity": "float",
            "price": "float",
            "status": "string (open|filled|cancelled)",
            "filled_qty": "float",
            "timestamp": "integer"
          },
          "raises": ["ConnectionError", "OrderNotFoundError"]
        },
        "fetch_orders_history": {
          "description": "Fetch order history (filled, cancelled, or open orders)",
          "params": {
            "limit": "integer (optional, default: 100)",
            "start_time": "integer (optional, timestamp in milliseconds)"
          },
          "returns": "array of Order objects",
          "raises": ["ConnectionError"]
        },
        "place_orders": {
          "description": "Place a batch of orders",
          "params": {
            "orders": "array of OrderRequest"
          },
          "returns": "array of Order objects",
          "raises": ["InsufficientBalanceError", "InvalidOrderError", "NetworkError"]
        },
        "cancel_orders": {
          "description": "Cancel multiple orders by order IDs",
          "params": {
            "order_ids": "array of string"
          },
          "returns": "void",
          "raises": ["OrderNotFoundError", "NetworkError"]
        },
        "cancel_all_orders": {
          "description": "Cancel all open orders for the symbol",
          "params": {},
          "returns": "void",
          "raises": ["ConnectionError"]
        },
        "fetch_realized_pnl": {
          "description": "Fetch total realized PnL from transaction history",
          "params": {
            "start_time": "integer (optional, timestamp in milliseconds)"
          },
          "returns": "float",
          "raises": ["ConnectionError"]
        },
        "fetch_commission": {
          "description": "Fetch total trading commission/fees",
          "params": {
            "start_time": "integer (optional, timestamp in milliseconds)"
          },
          "returns": "float",
          "raises": ["ConnectionError"]
        },
        "fetch_pnl_and_fees": {
          "description": "Fetch both realized PnL and commission fees",
          "params": {
            "start_time": "integer (optional, timestamp in milliseconds)"
          },
          "returns": {
            "realized_pnl": "float",
            "commission": "float",
            "net_pnl": "float"
          },
          "raises": ["ConnectionError"]
        }
      }
    },
    "BinanceClient": {
      "description": "Binance Futures exchange client / 币安期货交易所客户端",
      "extends": "ExchangeClient",
      "implementation": "src/trading/exchange.py#BinanceClient"
    },
    "HyperliquidClient": {
      "description": "Hyperliquid exchange client / Hyperliquid 交易所客户端",
      "extends": "ExchangeClient",
      "implementation": "src/trading/hyperliquid_client.py#HyperliquidClient",
      "notes": "Must implement same interface as BinanceClient for seamless integration. Connection and authentication should be handled in __init__ method, consistent with BinanceClient pattern. All order management methods (place_orders, cancel_orders, fetch_order, fetch_orders_history, etc.) must be implemented to support US-CORE-004-B requirements. / 必须实现与 BinanceClient 相同的接口以实现无缝集成。连接和认证应在 __init__ 方法中处理，与 BinanceClient 模式保持一致。所有订单管理方法（place_orders, cancel_orders, fetch_order, fetch_orders_history 等）必须实现以支持 US-CORE-004-B 需求。",
      "methods": {
        "__init__": {
          "description": "Initialize Hyperliquid client with API credentials and environment. Establishes connection and authenticates during initialization, consistent with BinanceClient pattern.",
          "params": {
            "api_key": "string (optional, from HYPERLIQUID_API_KEY env var)",
            "api_secret": "string (optional, from HYPERLIQUID_API_SECRET env var)",
            "testnet": "boolean (optional, from HYPERLIQUID_TESTNET env var)"
          },
          "returns": "void",
          "raises": ["ConnectionError", "AuthenticationError"],
          "notes": "Connects to testnet.hyperliquid.xyz if testnet=true, else api.hyperliquid.xyz. Connection and authentication are performed during initialization, not in a separate connect() method, to maintain interface consistency with BinanceClient."
        }
      },
      "order_methods_requirements": {
        "description": "Order management methods required for US-CORE-004-B / US-CORE-004-B 所需的订单管理方法",
        "required_methods": [
          "place_orders(orders) - Place batch of limit/market orders",
          "cancel_orders(order_ids) - Cancel multiple orders",
          "cancel_all_orders() - Cancel all open orders",
          "fetch_order(order_id) - Get order status by ID",
          "fetch_open_orders() - Get all open orders",
          "fetch_orders_history(limit, start_time) - Get order history"
        ],
        "error_handling": "Must map Hyperliquid-specific errors to standard exceptions (InsufficientFunds, InvalidOrder, OrderNotFound) with bilingual error messages / 必须将 Hyperliquid 特定错误映射到标准异常（余额不足、无效订单、订单未找到），并提供双语错误消息",
        "order_format": "Must convert between Hyperliquid API format and internal Order format for consistency with Binance / 必须在 Hyperliquid API 格式和内部 Order 格式之间转换，以与 Binance 保持一致"
      },
      "position_methods_requirements": {
        "description": "Position and balance tracking methods required for US-CORE-004-C / US-CORE-004-C 所需的仓位和余额追踪方法",
        "required_methods": [
          "fetch_balance() - Get account balance and margin information (AC-1, AC-6)",
          "fetch_positions() - Get all open positions across all symbols (AC-2, AC-7)",
          "fetch_position(symbol) - Get position for specific symbol (AC-2)",
          "fetch_position_history(limit, start_time, symbol) - Get position history (AC-5)",
          "fetch_realized_pnl(start_time) - Get realized PnL (AC-4)",
          "fetch_account_data() - Get position and balance for current symbol (existing method)"
        ],
        "pnl_calculation": "Unrealized PnL = (mark_price - entry_price) × size × side_multiplier. Realized PnL = sum of closed position PnL. Must handle both long and short positions correctly. / 未实现盈亏 = (标记价格 - 开仓价格) × 数量 × 方向乘数。已实现盈亏 = 已平仓仓位盈亏的总和。必须正确处理多头和空头仓位。",
        "data_format": "All monetary values must be in USDT. Position data must be converted from Hyperliquid API format to internal format for consistency with Binance. / 所有货币值必须以 USDT 为单位。仓位数据必须从 Hyperliquid API 格式转换为内部格式，以与 Binance 保持一致。",
        "error_handling": "Must provide clear bilingual error messages (Chinese and English) when API is unavailable or connection fails. / 当 API 不可用或连接失败时，必须提供清晰的双语错误消息（中文和英文）。",
        "integration": "Must integrate correctly with PerformanceTracker for performance metrics calculation (AC-9). / 必须与 PerformanceTracker 正确集成以进行性能指标计算（AC-9）。"
      }
    },
    "OrderManager": {
      "description": "Order placement and management / 订单管理",
      "methods": {
        "place_order": {
          "description": "Place a new order",
          "params": {
            "symbol": "string",
            "side": "string (BUY|SELL)",
            "order_type": "string (LIMIT|MARKET)",
            "quantity": "float",
            "price": "float (optional for MARKET)"
          },
          "returns": {
            "order_id": "string",
            "status": "string",
            "filled_qty": "float"
          },
          "raises": ["InsufficientBalanceError", "InvalidOrderError"]
        },
        "cancel_order": {
          "description": "Cancel an existing order",
          "params": {
            "order_id": "string"
          },
          "returns": "boolean",
          "raises": ["OrderNotFoundError"]
        },
        "get_open_orders": {
          "description": "Get all open orders",
          "params": {
            "symbol": "string (optional)"
          },
          "returns": "array of Order objects",
          "raises": ["ConnectionError"]
        }
      }
    },
    "Strategy": {
      "description": "Base strategy interface / 策略基础接口",
      "methods": {
        "initialize": {
          "description": "Initialize strategy with config",
          "params": {
            "config": "StrategyConfig"
          },
          "returns": "void",
          "raises": ["InvalidConfigError"]
        },
        "on_tick": {
          "description": "Called on each market data update",
          "params": {
            "market_data": "MarketData"
          },
          "returns": {
            "orders": "array of OrderRequest"
          },
          "raises": []
        },
        "get_status": {
          "description": "Get current strategy status",
          "params": {},
          "returns": {
            "name": "string",
            "running": "boolean",
            "pnl": "float",
            "position": "float"
          },
          "raises": []
        }
      }
    },
    "FixedSpreadStrategy": {
      "extends": "Strategy",
      "description": "Fixed spread market-making strategy / 固定价差做市策略",
      "config": {
        "spread": "float (0.001 - 0.05)",
        "quantity": "float",
        "max_position": "float",
        "skew_factor": "float (50 - 200)"
      }
    },
    "FundingRateStrategy": {
      "extends": "Strategy",
      "description": "Funding rate arbitrage strategy / 资金费率套利策略",
      "config": {
        "threshold": "float",
        "quantity": "float",
        "max_position": "float"
      }
    }
  },
  "data_types": {
    "MarketData": {
      "symbol": "string",
      "mid_price": "float",
      "best_bid": "float",
      "best_ask": "float",
      "timestamp": "datetime"
    },
    "Order": {
      "order_id": "string",
      "symbol": "string",
      "side": "string",
      "type": "string",
      "quantity": "float",
      "price": "float",
      "status": "string",
      "created_at": "datetime"
    },
    "OrderRequest": {
      "side": "string",
      "type": "string",
      "quantity": "float",
      "price": "float"
    },
    "StrategyConfig": {
      "name": "string",
      "symbol": "string",
      "params": "object"
    },
    "Position": {
      "symbol": "string",
      "side": "string (LONG|SHORT|NONE)",
      "size": "float",
      "entry_price": "float",
      "mark_price": "float",
      "unrealized_pnl": "float",
      "liquidation_price": "float",
      "timestamp": "integer (milliseconds)"
    },
    "PositionHistory": {
      "symbol": "string",
      "side": "string (LONG|SHORT)",
      "size": "float",
      "entry_price": "float",
      "exit_price": "float (null if still open)",
      "realized_pnl": "float",
      "open_time": "integer (milliseconds)",
      "close_time": "integer (milliseconds, null if still open)",
      "status": "string (open|closed)"
    }
  }
}


