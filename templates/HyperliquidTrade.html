<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Hyperliquid Trading Page / Hyperliquid äº¤æ˜“é¡µé¢</title>
    <style>
        body {
            margin: 0;
            font-family: "Inter", "PingFang SC", sans-serif;
            background: #f5f5fa;
            color: #1f2937;
        }

        a {
            color: #3b82f6;
            text-decoration: none;
        }

        .page {
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }

        .panel {
            background: #ffffff;
            border-radius: 14px;
            box-shadow: 0 8px 30px rgba(15, 23, 42, 0.08);
            padding: 24px;
            margin-bottom: 24px;
        }

        .panel h2 {
            margin: 0 0 16px;
            font-size: 20px;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 16px;
        }

        label {
            font-size: 13px;
            color: #6b7280;
            display: block;
            margin-bottom: 6px;
        }

        input,
        select {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
            background: #f9fafb;
            font-size: 14px;
            box-sizing: border-box;
        }

        .btn {
            border: none;
            border-radius: 8px;
            padding: 10px 16px;
            font-size: 14px;
            cursor: pointer;
        }

        .btn-primary {
            background: #4f46e5;
            color: #fff;
        }

        .btn-secondary {
            background: #e5e7eb;
            color: #374151;
        }

        .btn-success {
            background: #22c55e;
            color: #fff;
        }

        .btn-danger {
            background: #ef4444;
            color: #fff;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        table th,
        table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #f3f4f6;
        }

        .message {
            margin-top: 12px;
            font-size: 13px;
        }

        .message.error {
            color: #b91c1c;
        }

        .message.success {
            color: #059669;
        }

        .consensus-card {
            border: 1px dashed #c4b5fd;
            padding: 12px;
            border-radius: 10px;
            background: #f5f3ff;
            margin-top: 16px;
        }

        .nav-link {
            font-size: 14px;
            padding: 8px 14px;
            border-radius: 999px;
            background: #eef2ff;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .status-connected {
            background: #d1fae5;
            color: #065f46;
        }

        .status-disconnected {
            background: #fee2e2;
            color: #991b1b;
        }

        .network-badge {
            display: inline-block;
            padding: 6px 14px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            border: 2px solid;
        }

        .network-mainnet {
            background: #f0fdf4;
            color: #166534;
            border-color: #22c55e;
        }

        .network-testnet {
            background: #fef3c7;
            color: #92400e;
            border-color: #f59e0b;
        }

        .info-card {
            background: #f0f9ff;
            border: 1px solid #bae6fd;
            padding: 12px;
            border-radius: 8px;
            margin-top: 12px;
        }

        .provider-status-item {
            padding: 12px;
            border-radius: 8px;
            border: 2px solid #e5e7eb;
            background: #ffffff;
            transition: all 0.3s;
        }

        .provider-status-item.active {
            border-color: #3b82f6;
            background: #eff6ff;
        }

        .provider-status-item.completed {
            border-color: #22c55e;
            background: #f0fdf4;
        }

        .provider-status-item.failed {
            border-color: #ef4444;
            background: #fef2f2;
        }

        .step-indicator {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            background: #e5e7eb;
            color: #374151;
        }

        .step-indicator.active {
            background: #3b82f6;
            color: #ffffff;
        }

        .step-indicator.completed {
            background: #22c55e;
            color: #ffffff;
        }

        .step-indicator.failed {
            background: #ef4444;
            color: #ffffff;
        }

        .individual-progress-bar {
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 4px;
        }

        .individual-progress-bar-fill {
            height: 100%;
            background: #3b82f6;
            transition: width 0.3s;
        }
    </style>
    <!-- Error handling styles / é”™è¯¯å¤„ç†æ ·å¼ -->
    <link rel="stylesheet" href="/static/error_styles.css">
    <link rel="stylesheet" href="/static/debug_panel.css">
    <link rel="stylesheet" href="/static/validation.css">
    <link rel="stylesheet" href="/static/error_history.css">
    <!-- API Diagnostics and Error Handler / API è¯Šæ–­å’Œé”™è¯¯å¤„ç† -->
    <script src="/static/api_diagnostics.js"></script>
    <script src="/static/error_handler.js"></script>
    <script src="/static/debug_panel.js"></script>
    <script src="/static/validation.js"></script>
    <script src="/static/error_history.js"></script>
</head>

<body>
    <div class="page">
        <header>
            <div>
                <h1 style="margin:0;">Hyperliquid Trading Page / Hyperliquid äº¤æ˜“é¡µé¢</h1>
                <div style="font-size:13px; color:#6b7280;">Dedicated interface for Hyperliquid exchange trading / ä¸“ç”¨ Hyperliquid äº¤æ˜“æ‰€äº¤æ˜“ç•Œé¢</div>
            </div>
            <div style="display:flex; gap:12px; align-items:center;">
                <span id="networkStatus" class="network-badge" style="display:none;">
                    <span id="networkText">Mainnet / ä¸»ç½‘</span>
                </span>
                <span id="connectionStatus" class="status-badge status-disconnected">Checking...</span>
                <a class="nav-link" href="/">â† Back to Dashboard</a>
            </div>
        </header>

        <!-- Connection Status Panel / è¿æ¥çŠ¶æ€é¢æ¿ -->
        <section class="panel">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <h2 style="margin:0;">Connection Status / è¿æ¥çŠ¶æ€</h2>
                <div style="display:flex; gap:8px;">
                    <a href="https://hyperliquid-testnet.xyz" target="_blank" class="btn btn-secondary" style="font-size:12px; padding:6px 12px;">
                        ğŸ”— Testnet Website / æµ‹è¯•ç½‘ç½‘ç«™
                    </a>
                    <a href="https://hyperliquid.xyz" target="_blank" class="btn btn-secondary" style="font-size:12px; padding:6px 12px;">
                        ğŸ”— Mainnet Website / ä¸»ç½‘ç½‘ç«™
                    </a>
                </div>
            </div>
            <div id="connectionInfo" class="info-card" style="margin-top:16px;">
                <div>Exchange: <strong>Hyperliquid</strong></div>
                <div id="connectionDetails" style="margin-top:8px; font-size:13px; color:#6b7280;">Loading connection status...</div>
                <div id="testnetConnectionHint" style="margin-top:12px; padding:12px; background:#fef3c7; border-radius:8px; border-left:3px solid #f59e0b; display:none;">
                    <div style="font-size:12px; font-weight:600; margin-bottom:6px; color:#92400e;">
                        ğŸ”— Connect to Testnet / è¿æ¥åˆ°æµ‹è¯•ç½‘
                    </div>
                    <div style="font-size:11px; color:#78350f; line-height:1.6; margin-bottom:8px;">
                        To connect to Hyperliquid Testnet, set the environment variable and restart the server:
                        è¦è¿æ¥åˆ° Hyperliquid æµ‹è¯•ç½‘ï¼Œè¯·è®¾ç½®ç¯å¢ƒå˜é‡å¹¶é‡å¯æœåŠ¡å™¨ï¼š
                    </div>
                    <div style="background:#1f2937; color:#f9fafb; padding:8px; border-radius:6px; font-family:monospace; font-size:11px; margin-bottom:8px;">
                        export HYPERLIQUID_TESTNET="true"<br>
                        export HYPERLIQUID_API_KEY="your_testnet_key"<br>
                        export HYPERLIQUID_API_SECRET="your_testnet_secret"
                    </div>
                    <div style="display:flex; gap:8px; flex-wrap:wrap;">
                        <a href="https://hyperliquid-testnet.xyz" target="_blank" style="font-size:11px; color:#3b82f6; text-decoration:underline;">
                            ğŸ“– Testnet Documentation / æµ‹è¯•ç½‘æ–‡æ¡£
                        </a>
                        <a href="https://hyperliquid.xyz" target="_blank" style="font-size:11px; color:#3b82f6; text-decoration:underline;">
                            ğŸ“– Mainnet Documentation / ä¸»ç½‘æ–‡æ¡£
                        </a>
                    </div>
                </div>
            </div>
        </section>

        <!-- Position and Balance Panel / ä»“ä½ä¸ä½™é¢é¢æ¿ -->
        <section class="panel">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <h2 style="margin:0;">Position & Balance / ä»“ä½ä¸ä½™é¢</h2>
                <button class="btn btn-secondary" onclick="refreshPosition()">ğŸ”„ Refresh</button>
            </div>
            <div id="positionStatus" class="message" style="color:#6b7280; margin-top:12px;">Loading position data...</div>
            <div id="positionData" style="display:none; margin-top:16px;">
                <div class="grid">
                    <div>
                        <label>Total Balance / æ€»ä½™é¢</label>
                        <div style="font-size:20px; font-weight:bold;" id="totalBalance">--</div>
                    </div>
                    <div>
                        <label>Available Balance / å¯ç”¨ä½™é¢</label>
                        <div style="font-size:20px; font-weight:bold;" id="availableBalance">--</div>
                    </div>
                    <div>
                        <label>Position Amount / ä»“ä½æ•°é‡</label>
                        <div style="font-size:20px; font-weight:bold;" id="positionAmount">--</div>
                    </div>
                    <div>
                        <label>Unrealized PnL / æœªå®ç°ç›ˆäº</label>
                        <div style="font-size:20px; font-weight:bold;" id="unrealizedPnL">--</div>
                    </div>
                </div>
                <div style="margin-top:16px;">
                    <h3 style="font-size:14px; margin-bottom:8px;">Open Positions / æœªå¹³ä»“</h3>
                    <div id="positionsTable" style="overflow-x:auto;">
                        <table>
                            <thead>
                                <tr style="background:#f3f4f6;">
                                    <th>Symbol / äº¤æ˜“å¯¹</th>
                                    <th>Side / æ–¹å‘</th>
                                    <th>Size / æ•°é‡</th>
                                    <th>Entry Price / å…¥åœºä»·</th>
                                    <th>Mark Price / æ ‡è®°ä»·</th>
                                    <th>PnL / ç›ˆäº</th>
                                </tr>
                            </thead>
                            <tbody id="positionsTableBody">
                                <tr><td colspan="6" style="text-align:center; color:#6b7280;">No open positions / æ— æœªå¹³ä»“</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </section>

        <!-- Strategy Control Panel / ç­–ç•¥æ§åˆ¶é¢æ¿ -->
        <section class="panel">
            <h2>Fixed Spread Strategy Control Panel / å›ºå®šä»·å·®ç­–ç•¥æ§åˆ¶é¢æ¿</h2>
            <div class="grid">
                <div>
                    <label>Trading Pair / äº¤æ˜“å¯¹</label>
                    <select id="pairSelect" onchange="switchPair()">
                        <option value="ETH/USDC:USDC" data-price="">ETH/USDC:USDC (--)</option>
                        <option value="BTC/USDC:USDC" data-price="">BTC/USDC:USDC (--)</option>
                        <option value="SOL/USDC:USDC" data-price="">SOL/USDC:USDC (--)</option>
                    </select>
                </div>
            </div>
            <div class="grid" style="margin-top: 16px;">
                <div>
                    <label>Spread (%) / ä»·å·® (%)</label>
                    <input type="number" id="spreadInput" step="0.01" value="1.5">
                </div>
                <div>
                    <label>Quantity / æ•°é‡</label>
                    <input type="number" id="quantityInput" step="0.01" value="0.1">
                </div>
                <div>
                    <label>Leverage / æ æ†</label>
                    <input type="number" id="leverageInput" min="1" max="125" value="5">
                </div>
            </div>
            <div style="margin-top: 8px; font-size: 12px; color: #6b7280;">
                Note: Fixed Spread Strategy does not use Skew Factor / æ³¨æ„ï¼šå›ºå®šä»·å·®ç­–ç•¥ä¸ä½¿ç”¨å€¾æ–œå› å­
            </div>
            <div style="display:flex; gap:12px; margin-top:16px;">
                <button class="btn btn-primary" onclick="updateConfig()">ğŸ’¾ Save Strategy Config</button>
                <button class="btn btn-secondary" onclick="updateLeverage()">âš¡ Update Leverage</button>
            </div>
            <div id="controlMessage" class="message"></div>
        </section>

        <!-- LLM Evaluation Panel / LLM è¯„ä¼°é¢æ¿ -->
        <section class="panel">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <div>
                    <h2 style="margin:0;">Multi-LLM Evaluation / å¤šæ¨¡å‹è¯„ä¼°</h2>
                    <div style="font-size:13px; color:#6b7280;">Select LLM models to use for evaluation / é€‰æ‹©ç”¨äºè¯„ä¼°çš„ LLM æ¨¡å‹</div>
                </div>
                <button id="runEvaluationBtn" class="btn btn-primary" onclick="runEvaluation()">ğŸš€ Run Evaluation</button>
            </div>
            
            <!-- LLM Model Selection / LLM æ¨¡å‹é€‰æ‹© -->
            <div style="margin-top:16px; padding:16px; background:#f9fafb; border-radius:8px; border:1px solid #e5e7eb;">
                <div style="font-size:13px; font-weight:600; margin-bottom:12px; color:#374151;">Select LLM Models / é€‰æ‹© LLM æ¨¡å‹:</div>
                <div style="display:flex; gap:20px; flex-wrap:wrap;">
                    <label style="display:flex; align-items:center; gap:8px; cursor:pointer; font-size:14px;">
                        <input type="checkbox" id="modelGemini" class="llm-model-checkbox" value="gemini" checked style="width:18px; height:18px; cursor:pointer;">
                        <span>Gemini</span>
                    </label>
                    <label style="display:flex; align-items:center; gap:8px; cursor:pointer; font-size:14px;">
                        <input type="checkbox" id="modelOpenAI" class="llm-model-checkbox" value="openai" checked style="width:18px; height:18px; cursor:pointer;">
                        <span>OpenAI</span>
                    </label>
                    <label style="display:flex; align-items:center; gap:8px; cursor:pointer; font-size:14px;">
                        <input type="checkbox" id="modelClaude" class="llm-model-checkbox" value="claude" checked style="width:18px; height:18px; cursor:pointer;">
                        <span>Claude</span>
                    </label>
                </div>
                <div style="margin-top:8px; font-size:12px; color:#6b7280;" id="selectedModelsHint">
                    All models selected / å·²é€‰æ‹©æ‰€æœ‰æ¨¡å‹
                </div>
            </div>
            
            <div id="evaluationStatusText" class="message" style="color:#6b7280; margin-top:12px;">Ready.</div>
            <div id="evaluationErrorBox" class="message error" style="display:none;"></div>

            <!-- Evaluation Progress Display / è¯„ä¼°è¿›åº¦æ˜¾ç¤º (AC-11) -->
            <div id="evaluationProgressPanel" style="display:none; margin-top:16px; padding:16px; background:#f9fafb; border-radius:8px; border:1px solid #e5e7eb;">
                <!-- Overall Status / æ€»ä½“çŠ¶æ€ -->
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
                    <div>
                        <div style="font-weight:bold; font-size:14px;" id="overallStatusText">Evaluation in Progress / è¯„ä¼°è¿›è¡Œä¸­</div>
                        <div style="font-size:12px; color:#6b7280; margin-top:4px;" id="elapsedTimeText">Elapsed: 0m 0s / å·²ç”¨æ—¶é—´: 0åˆ† 0ç§’</div>
                    </div>
                    <div id="overallStatusIcon" style="font-size:20px;">â³</div>
                </div>
                
                <!-- Overall Progress Bar / æ€»ä½“è¿›åº¦æ¡ -->
                <div style="margin-bottom:16px;">
                    <div style="display:flex; justify-content:space-between; margin-bottom:4px;">
                        <span style="font-size:12px; color:#6b7280;" id="overallProgressText">0 / 0 providers completed / 0 / 0 ä¸ªæä¾›å•†å·²å®Œæˆ</span>
                        <span style="font-size:12px; color:#6b7280;" id="overallProgressPercent">0%</span>
                    </div>
                    <div style="height:8px; background:#e5e7eb; border-radius:4px; overflow:hidden;">
                        <div id="overallProgressBar" style="height:100%; background:#3b82f6; width:0%; transition:width 0.3s;"></div>
                    </div>
                </div>

                <!-- Provider Status List / æä¾›å•†çŠ¶æ€åˆ—è¡¨ -->
                <div id="providerStatusList" style="display:flex; flex-direction:column; gap:12px;">
                    <!-- Provider status items will be dynamically inserted here -->
                </div>
            </div>

            <div id="evaluationConsensusCard" class="consensus-card" style="display:none;">
                <div style="font-size:14px; font-weight:bold; color:#6d28d9;">ğŸ¤ Consensus Recommendation / å…±è¯†å»ºè®®</div>
                <div style="margin-top:8px; font-size:13px;">
                    <div>Strategy / ç­–ç•¥: <span id="evaluationConsensusStrategy" style="font-weight:bold;">--</span></div>
                    <div>Spread / Qty / Lev / ä»·å·® / æ•°é‡ / æ æ†:
                        <span id="evaluationConsensusParams" style="font-weight:bold;">--</span>
                    </div>
                </div>
                <div id="evaluationConsensusStats" style="margin-top:6px; font-size:12px; color:#4b5563;">--</div>
                <div id="evaluationConsensusReasoning" style="margin-top:8px; font-size:12px; color:#6b7280;">--</div>
                <div style="display:flex; gap:8px; margin-top:12px;">
                    <button class="btn btn-success" style="flex:1;"
                        onclick="applyEvaluation('consensus')">Apply Consensus / åº”ç”¨å…±è¯†</button>
                    <button id="startBotBtn" class="btn btn-primary" style="flex:1; display:none;"
                        onclick="startBotWithLLMSuggestion()">ğŸš€ Start Bot / å¯åŠ¨æœºå™¨äºº</button>
                    <button id="stopBotBtn" class="btn btn-danger" style="flex:1; display:none;"
                        onclick="stopBot()">â¹ Stop Bot / åœæ­¢æœºå™¨äºº</button>
                </div>
            </div>

            <div id="evaluationResultsWrapper" style="margin-top:20px; display:none;">
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <div style="font-size:13px; font-weight:bold;">Model Comparison / æ¨¡å‹å¯¹æ¯”</div>
                    <div id="evaluationLastRun" style="font-size:11px; color:#6b7280;"></div>
                </div>
                <div style="overflow-x:auto; margin-top:8px;">
                    <table>
                        <thead>
                            <tr style="background:#f3f4f6;">
                                <th>Rank</th>
                                <th>Provider</th>
                                <th>Strategy</th>
                                <th>Spread</th>
                                <th>Qty</th>
                                <th>Lev</th>
                                <th>Confidence</th>
                                <th>PnL</th>
                                <th>Sharpe</th>
                                <th>Win%</th>
                                <th>Score</th>
                                <th></th>
                            </tr>
                        </thead>
                        <tbody id="evaluationResultsBody"></tbody>
                    </table>
                </div>
            </div>
        </section>

        <!-- Orders Panel / è®¢å•é¢æ¿ -->
        <section class="panel">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <div>
                    <h2 style="margin:0;">Current Orders / å½“å‰è®¢å•</h2>
                    <div style="font-size:13px; color:#6b7280;">Real-time order status</div>
                </div>
                <button class="btn btn-secondary" onclick="refreshOrders()">ğŸ”„ Refresh</button>
            </div>
            <div id="ordersStatusText" class="message" style="color:#6b7280; margin-top:12px;">Loading orders...</div>
            <div id="ordersTableWrapper" style="margin-top:16px; display:none;">
                <div style="overflow-x:auto;">
                    <table>
                        <thead>
                            <tr style="background:#f3f4f6;">
                                <th>Order ID</th>
                                <th>Side</th>
                                <th>Price</th>
                                <th>Quantity</th>
                                <th>Status</th>
                                <th>Time</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody id="ordersTableBody"></tbody>
                    </table>
                </div>
                <div id="ordersEmptyMessage" style="text-align:center; padding:24px; color:#6b7280; display:none;">
                    No active orders / æ— æ´»è·ƒè®¢å•
                </div>
            </div>
        </section>

        <!-- Error History Panel / é”™è¯¯å†å²é¢æ¿ -->
        <section class="panel">
            <div style="display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:12px;">
                <div>
                    <div style="font-weight:600;">Diagnostics / è°ƒè¯•å·¥å…·</div>
                    <div style="font-size:12px; color:#6b7280;">Recent API calls + errors</div>
                </div>
                <button class="btn btn-secondary" onclick="downloadDebugBundle()" title="Export recent diagnostics / å¯¼å‡ºæœ€è¿‘è¯Šæ–­">
                    â¬‡ï¸ Export Debug Bundle
                </button>
            </div>
            <div id="errorHistoryPanel"></div>
        </section>
    </div>

    <script>
        const controlMessage = document.getElementById('controlMessage');
        let currentEvalSymbol = 'ETHUSDC';
        let evaluationState = {
            loading: false,
            results: [],
            aggregated: null,
            lastError: null,
            lastRunSymbol: null,
            lastRunAt: null,
            startTime: null,
            elapsedInterval: null,
            providers: ['Gemini', 'OpenAI', 'Claude'], // Expected providers
            providerStatus: {}, // Track status for each provider
        };

        function showMessage(el, text, isError = false) {
            if (!el) return;
            el.innerText = text;
            el.classList.toggle('error', isError);
            el.classList.toggle('success', !isError);
        }

        function normalizeSymbol(symbol) {
            if (!symbol) return 'ETHUSDC';
            return symbol.toUpperCase().replace(/[:\/-]/g, '');
        }

        async function downloadDebugBundle() {
            const now = new Date();
            const filename = `hyperliquid-debug-${now.toISOString().replace(/[:.]/g, '-')}.json`;
            const fetchFn = window.diagnosticFetch || window.fetch;
            const bundle = {
                collected_at: now.toISOString(),
                trace_id: null,
                selected_symbol: (document.getElementById('pairSelect') || {}).value || null,
                api_calls: [],
                error_history: null,
            };

            try {
                bundle.api_calls = (window.apiDiagnostics && window.apiDiagnostics.getRecentCalls)
                    ? window.apiDiagnostics.getRecentCalls({ limit: 50 })
                    : [];
            } catch (e) {
                console.error('Failed to collect apiDiagnostics', e);
            }

            try {
                const res = await fetchFn('/api/status');
                bundle.error_history = await res.json();
                bundle.trace_id = res.headers.get('X-Trace-ID') || null;
            } catch (e) {
                bundle.error_history = { error: `Failed to fetch /api/status: ${e.message}` };
            }

            const blob = new Blob([JSON.stringify(bundle, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            link.remove();
            URL.revokeObjectURL(url);
        }

        // Connection Status / è¿æ¥çŠ¶æ€
        let lastConnectionCheckTime = 0;
        const CONNECTION_CHECK_INTERVAL = 15000; // Check connection every 15 seconds / æ¯ 15 ç§’æ£€æŸ¥ä¸€æ¬¡è¿æ¥
        
        async function checkConnection() {
            // Prevent duplicate requests / é˜²æ­¢é‡å¤è¯·æ±‚
            if (isCheckingConnection) return;
            
            // Throttle connection checks to avoid excessive API calls / é™åˆ¶è¿æ¥æ£€æŸ¥ä»¥é¿å…è¿‡å¤š API è°ƒç”¨
            const now = Date.now();
            if (now - lastConnectionCheckTime < CONNECTION_CHECK_INTERVAL) {
                return;
            }
            
            isCheckingConnection = true;
            lastConnectionCheckTime = now;
            
            try {
                // Get currently selected pair / è·å–å½“å‰é€‰ä¸­çš„äº¤æ˜“å¯¹
                const pairSelect = document.getElementById('pairSelect');
                const selectedSymbol = pairSelect ? pairSelect.value : null;
                
                // Use Hyperliquid status API to check connection (faster than evaluation API)
                // ä½¿ç”¨ Hyperliquid çŠ¶æ€ API æ£€æŸ¥è¿æ¥ï¼ˆæ¯”è¯„ä¼° API æ›´å¿«ï¼‰
                // If a specific symbol is selected, we'll update the status with that symbol's price
                // å¦‚æœé€‰æ‹©äº†ç‰¹å®šäº¤æ˜“å¯¹ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨è¯¥äº¤æ˜“å¯¹çš„ä»·æ ¼æ›´æ–°çŠ¶æ€
                const res = await diagnosticFetch('/api/hyperliquid/status');
                const data = await res.json();
                
                const statusEl = document.getElementById('connectionStatus');
                const detailsEl = document.getElementById('connectionDetails');
                const networkEl = document.getElementById('networkStatus');
                const networkTextEl = document.getElementById('networkText');
                
                if (!statusEl || !detailsEl) {
                    return; // Elements not found, page might not be fully loaded
                }
                
                // Handle rate limit error / å¤„ç†é€Ÿç‡é™åˆ¶é”™è¯¯
                if (data.error && (data.error.includes('429') || data.error.includes('Too Many Requests') || data.error.includes('é€Ÿç‡é™åˆ¶'))) {
                    statusEl.className = 'status-badge status-disconnected';
                    statusEl.innerText = 'Rate Limited / é€Ÿç‡é™åˆ¶';
                    detailsEl.innerHTML = '<span style="color:#f59e0b;">Too many requests. Please wait... / è¯·æ±‚è¿‡å¤šï¼Œè¯·ç¨å€™...</span>';
                    // Extend refresh interval on rate limit / é€Ÿç‡é™åˆ¶æ—¶å»¶é•¿åˆ·æ–°é—´éš”
                    if (connectionRefreshInterval) {
                        clearInterval(connectionRefreshInterval);
                        connectionRefreshInterval = setInterval(checkConnection, 60000); // 1 minute
                    }
                    return;
                }
                
                // Update network status (testnet/mainnet)
                // æ›´æ–°ç½‘ç»œçŠ¶æ€ï¼ˆæµ‹è¯•ç½‘/ä¸»ç½‘ï¼‰
                const isTestnet = data.testnet === true;
                const testnetHintEl = document.getElementById('testnetConnectionHint');
                
                if (networkEl && networkTextEl) {
                    networkEl.style.display = 'inline-block';
                    if (isTestnet) {
                        networkEl.className = 'network-badge network-testnet';
                        networkTextEl.innerText = 'âš ï¸ TESTNET / æµ‹è¯•ç½‘';
                    } else {
                        networkEl.className = 'network-badge network-mainnet';
                        networkTextEl.innerText = 'âœ“ MAINNET / ä¸»ç½‘';
                    }
                }
                
                // Show/hide testnet connection hint based on connection status
                // æ ¹æ®è¿æ¥çŠ¶æ€æ˜¾ç¤º/éšè—æµ‹è¯•ç½‘è¿æ¥æç¤º
                if (testnetHintEl) {
                    // Only show hint if not connected or if connected to mainnet (to suggest switching to testnet)
                    // ä»…åœ¨æœªè¿æ¥æˆ–è¿æ¥åˆ°ä¸»ç½‘æ—¶æ˜¾ç¤ºæç¤ºï¼ˆå»ºè®®åˆ‡æ¢åˆ°æµ‹è¯•ç½‘ï¼‰
                    if (!data.connected || !isTestnet) {
                        testnetHintEl.style.display = 'block';
                    } else {
                        // Already connected to testnet, hide the hint
                        // å·²è¿æ¥åˆ°æµ‹è¯•ç½‘ï¼Œéšè—æç¤º
                        testnetHintEl.style.display = 'none';
                    }
                }
                
                if (data.error || !data.connected) {
                    // Not connected
                    statusEl.className = 'status-badge status-disconnected';
                    statusEl.innerText = 'Disconnected / æœªè¿æ¥';
                    const errorMsg = data.error || 'Hyperliquid exchange not connected / Hyperliquid äº¤æ˜“æ‰€æœªè¿æ¥';
                    detailsEl.innerHTML = `<span style="color:#991b1b;">${errorMsg}</span>`;
                } else {
                    // Connected - show price for currently selected pair / å·²è¿æ¥ - æ˜¾ç¤ºå½“å‰é€‰ä¸­äº¤æ˜“å¯¹çš„ä»·æ ¼
                    statusEl.className = 'status-badge status-connected';
                    statusEl.innerText = 'Connected / å·²è¿æ¥';
                    
                    // Get currently selected symbol / è·å–å½“å‰é€‰ä¸­çš„äº¤æ˜“å¯¹
                    const pairSelect = document.getElementById('pairSelect');
                    const selectedSymbol = pairSelect ? pairSelect.value : null;
                    
                    // Use selected symbol price if available, otherwise use status API price / å¦‚æœå¯ç”¨åˆ™ä½¿ç”¨é€‰ä¸­äº¤æ˜“å¯¹ä»·æ ¼ï¼Œå¦åˆ™ä½¿ç”¨çŠ¶æ€ API ä»·æ ¼
                    let displaySymbol = selectedSymbol || data.symbol || 'N/A';
                    let displayPrice = null;
                    
                    // Try to get price from cache first / å…ˆå°è¯•ä»ç¼“å­˜è·å–ä»·æ ¼
                    if (selectedSymbol && pairPrices[selectedSymbol] !== null && pairPrices[selectedSymbol] !== undefined) {
                        displayPrice = pairPrices[selectedSymbol];
                    } else if (data.mid_price && data.mid_price > 0) {
                        // Fallback to status API price / å›é€€åˆ°çŠ¶æ€ API ä»·æ ¼
                        displayPrice = data.mid_price;
                    } else if (selectedSymbol) {
                        // Try to fetch price for selected symbol / å°è¯•è·å–é€‰ä¸­äº¤æ˜“å¯¹çš„ä»·æ ¼
                        displayPrice = await getPairPrice(selectedSymbol);
                    }
                    
                    // Convert USDT to USDC for Hyperliquid display / å°† USDT è½¬æ¢ä¸º USDC ç”¨äº Hyperliquid æ˜¾ç¤º
                    if (displaySymbol.includes('USDT')) {
                        displaySymbol = displaySymbol.replace(/USDT/g, 'USDC');
                    }
                    
                    const balance = data.balance || 0;
                    const priceText = displayPrice !== null && displayPrice > 0 
                        ? `$${displayPrice.toFixed(2)}` 
                        : '--';
                    
                    detailsEl.innerHTML = `
                        <div>Symbol: <strong>${displaySymbol}</strong> | Price: <strong>${priceText}</strong></div>
                        <div style="margin-top:4px;">Balance: <strong>${balance.toFixed(2)} USDC</strong></div>
                    `;
                }
                
                // Reset refresh interval on success / æˆåŠŸæ—¶é‡ç½®åˆ·æ–°é—´éš”
                if (connectionRefreshInterval) {
                    clearInterval(connectionRefreshInterval);
                    connectionRefreshInterval = setInterval(checkConnection, 30000); // 30 seconds
                }
            } catch (err) {
                const statusEl = document.getElementById('connectionStatus');
                const detailsEl = document.getElementById('connectionDetails');
                if (statusEl && detailsEl) {
                    statusEl.className = 'status-badge status-disconnected';
                    statusEl.innerText = 'Error / é”™è¯¯';
                    
                    // Provide user-friendly error message / æä¾›ç”¨æˆ·å‹å¥½çš„é”™è¯¯æ¶ˆæ¯
                    let errorMsg = err.message || 'Unknown error / æœªçŸ¥é”™è¯¯';
                    
                    // Handle AbortError / å¤„ç† AbortError
                    if (err.name === 'AbortError' || errorMsg.includes('aborted') || errorMsg.includes('signal is aborted')) {
                        errorMsg = 'Request timeout. The server may be slow or rate-limited. / è¯·æ±‚è¶…æ—¶ã€‚æœåŠ¡å™¨å¯èƒ½è¾ƒæ…¢æˆ–å—åˆ°é€Ÿç‡é™åˆ¶ã€‚';
                    } else if (errorMsg.includes('timeout')) {
                        errorMsg = 'Request timeout. Please try again. / è¯·æ±‚è¶…æ—¶ã€‚è¯·é‡è¯•ã€‚';
                    }
                    
                    detailsEl.innerHTML = `<span style="color:#991b1b;">Failed to check connection: ${errorMsg} / æ£€æŸ¥è¿æ¥å¤±è´¥ï¼š${errorMsg}</span>`;
                }
            } finally {
                isCheckingConnection = false;
            }
        }

        // Track if refresh is in progress to avoid duplicate requests
        // è·Ÿè¸ªåˆ·æ–°æ˜¯å¦æ­£åœ¨è¿›è¡Œï¼Œé¿å…é‡å¤è¯·æ±‚
        let isRefreshingPosition = false;
        let isRefreshingOrders = false;
        let isCheckingConnection = false;

        // Position and Balance / ä»“ä½ä¸ä½™é¢
        async function refreshPosition() {
            // Prevent duplicate requests / é˜²æ­¢é‡å¤è¯·æ±‚
            if (isRefreshingPosition) return;
            isRefreshingPosition = true;
            
            try {
                const statusEl = document.getElementById('positionStatus');
                if (statusEl) {
                    statusEl.innerText = 'Loading position data... / æ­£åœ¨åŠ è½½ä»“ä½æ•°æ®...';
                    statusEl.classList.remove('error');
                }
                
                // Get Hyperliquid-specific status / è·å– Hyperliquid ç‰¹å®šçŠ¶æ€
                const res = await diagnosticFetch('/api/hyperliquid/status');
                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                }
                const data = await res.json();
                
                if (data.error) {
                    const positionData = document.getElementById('positionData');
                    if (positionData) positionData.style.display = 'none';
                    
                    // Check for rate limit error / æ£€æŸ¥é€Ÿç‡é™åˆ¶é”™è¯¯
                    if (data.error.includes('429') || data.error.includes('Too Many Requests') || data.error.includes('é€Ÿç‡é™åˆ¶')) {
                        if (statusEl) {
                            statusEl.innerText = 'Rate limit exceeded. Please wait... / é€Ÿç‡é™åˆ¶å·²è¶…å‡ºï¼Œè¯·ç¨å€™...';
                            statusEl.classList.add('error');
                        }
                        // Extend refresh interval on rate limit / é€Ÿç‡é™åˆ¶æ—¶å»¶é•¿åˆ·æ–°é—´éš”
                        if (positionRefreshInterval) {
                            clearInterval(positionRefreshInterval);
                            positionRefreshInterval = setInterval(refreshPosition, 60000); // 1 minute
                        }
                    } else {
                        if (statusEl) {
                            statusEl.innerText = data.error;
                            statusEl.classList.add('error');
                        }
                    }
                    return;
                }
                
                const positionData = document.getElementById('positionData');
                const totalBalanceEl = document.getElementById('totalBalance');
                const availableBalanceEl = document.getElementById('availableBalance');
                const positionAmountEl = document.getElementById('positionAmount');
                const unrealizedPnLEl = document.getElementById('unrealizedPnL');
                const positionsTableBody = document.getElementById('positionsTableBody');
                
                // Always show data if connected, even if balance is 0
                // å¦‚æœå·²è¿æ¥ï¼Œå³ä½¿ä½™é¢ä¸º 0 ä¹Ÿæ˜¾ç¤ºæ•°æ®
                if (data.connected && data.balance !== undefined) {
                    if (positionData) positionData.style.display = 'block';
                    if (totalBalanceEl) totalBalanceEl.innerText = `$${(data.balance || 0).toFixed(2)}`;
                    if (availableBalanceEl) availableBalanceEl.innerText = `$${(data.available_balance || 0).toFixed(2)}`;
                    if (positionAmountEl) positionAmountEl.innerText = `${(data.position || 0).toFixed(4)}`;
                    if (unrealizedPnLEl) unrealizedPnLEl.innerText = `$${((data.unrealized_pnl || 0)).toFixed(2)}`;
                    if (statusEl) {
                        statusEl.innerText = 'Position data loaded / ä»“ä½æ•°æ®å·²åŠ è½½';
                        statusEl.classList.remove('error');
                    }
                    
                    // Populate positions table / å¡«å……ä»“ä½è¡¨æ ¼
                    if (positionsTableBody) {
                        if (data.positions && Array.isArray(data.positions) && data.positions.length > 0) {
                            const rows = data.positions.map(pos => {
                                const symbol = pos.symbol || pos.coin || '--';
                                const side = pos.side || (pos.szi > 0 ? 'LONG' : 'SHORT') || '--';
                                const size = Math.abs(pos.szi || pos.size || 0);
                                const entryPrice = pos.entryPx || pos.entry_price || 0;
                                const markPrice = pos.markPx || pos.mark_price || data.mid_price || 0;
                                const pnl = pos.unrealizedPnl || pos.unrealized_pnl || 0;
                                
                                return `
                                    <tr>
                                        <td>${symbol}</td>
                                        <td><span style="color:${side === 'LONG' || side === 'BUY' ? '#22c55e' : '#ef4444'}; font-weight:bold;">${side}</span></td>
                                        <td>${size.toFixed(4)}</td>
                                        <td>$${entryPrice.toFixed(2)}</td>
                                        <td>$${markPrice.toFixed(2)}</td>
                                        <td style="color:${pnl >= 0 ? '#22c55e' : '#ef4444'};">$${pnl.toFixed(2)}</td>
                                    </tr>
                                `;
                            }).join('');
                            positionsTableBody.innerHTML = rows;
                        } else {
                            positionsTableBody.innerHTML = '<tr><td colspan="6" style="text-align:center; color:#6b7280;">No open positions / æ— æœªå¹³ä»“</td></tr>';
                        }
                    }
                } else {
                    if (positionData) positionData.style.display = 'none';
                    if (statusEl) {
                        statusEl.innerText = 'Position data not available / ä»“ä½æ•°æ®ä¸å¯ç”¨';
                        statusEl.classList.add('error');
                    }
                }
            } catch (err) {
                const statusEl = document.getElementById('positionStatus');
                if (statusEl) {
                    statusEl.innerText = `Error: ${err.message} / é”™è¯¯: ${err.message}`;
                    statusEl.classList.add('error');
                }
                const positionData = document.getElementById('positionData');
                if (positionData) positionData.style.display = 'none';
            } finally {
                isRefreshingPosition = false;
            }
        }

        async function loadStatus() {
            try {
                // Get Hyperliquid-specific status / è·å– Hyperliquid ç‰¹å®šçŠ¶æ€
                const res = await diagnosticFetch('/api/hyperliquid/status');
                const data = await res.json();
                
                if (data.error) {
                    showMessage(controlMessage, data.error, true);
                    return;
                }
                
                // Update input fields from status / ä»çŠ¶æ€æ›´æ–°è¾“å…¥æ¡†
                // Update spread input (convert from decimal to percentage) / æ›´æ–°ä»·å·®è¾“å…¥ï¼ˆä»å°æ•°è½¬æ¢ä¸ºç™¾åˆ†æ¯”ï¼‰
                if (data.spread !== undefined && data.spread !== null) {
                    const spreadInput = document.getElementById('spreadInput');
                    if (spreadInput) {
                        spreadInput.value = (data.spread * 100).toFixed(2);
                    }
                }
                // Update quantity input / æ›´æ–°æ•°é‡è¾“å…¥
                if (data.quantity !== undefined && data.quantity !== null) {
                    document.getElementById('quantityInput').value = data.quantity;
                } else {
                    document.getElementById('quantityInput').value = 0.1;
                }
                // Update leverage input / æ›´æ–°æ æ†è¾“å…¥
                if (data.leverage !== undefined && data.leverage !== null) {
                    document.getElementById('leverageInput').value = data.leverage;
                } else {
                    document.getElementById('leverageInput').value = 5;
                }
                currentEvalSymbol = normalizeSymbol(data.symbol);

                const pairSelect = document.getElementById('pairSelect');
                if (pairSelect && data.symbol) {
                    for (const option of pairSelect.options) {
                        if (option.value.toUpperCase() === data.symbol.toUpperCase()) {
                            pairSelect.value = option.value;
                            break;
                        }
                    }
                }

                // Check bot running status from /api/status and update buttons / ä» /api/status æ£€æŸ¥ bot è¿è¡ŒçŠ¶æ€å¹¶æ›´æ–°æŒ‰é’®
                try {
                    const statusRes = await diagnosticFetch('/api/status');
                    const statusData = await statusRes.json();
                    if (statusData && typeof statusData.active === 'boolean') {
                        updateBotControlButtons(statusData.active);
                    } else {
                        // If status is not available, default to stopped state / å¦‚æœçŠ¶æ€ä¸å¯ç”¨ï¼Œé»˜è®¤ä¸ºåœæ­¢çŠ¶æ€
                        updateBotControlButtons(false);
                    }
                } catch (statusErr) {
                    console.warn('Failed to fetch bot status for button update / è·å– bot çŠ¶æ€ä»¥æ›´æ–°æŒ‰é’®å¤±è´¥:', statusErr);
                    // Default to stopped state on error / å‡ºé”™æ—¶é»˜è®¤ä¸ºåœæ­¢çŠ¶æ€
                    updateBotControlButtons(false);
                }
            } catch (err) {
                showMessage(controlMessage, `Failed to load status: ${err.message}`, true);
            }
        }

        async function updateConfig() {
            try {
                const payload = {
                    spread: parseFloat(document.getElementById('spreadInput').value || '0'),
                    quantity: parseFloat(document.getElementById('quantityInput').value || '0'),
                    strategy_type: 'fixed_spread',
                    strategy_id: 'default',
                };
                // Use Hyperliquid-specific config endpoint / ä½¿ç”¨ Hyperliquid ç‰¹å®šé…ç½®ç«¯ç‚¹
                const res = await diagnosticFetch('/api/hyperliquid/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                const data = await res.json();
                if (data.error) throw new Error(data.error);
                showMessage(controlMessage, 'Strategy config updated. / ç­–ç•¥é…ç½®å·²æ›´æ–°ã€‚');
            } catch (err) {
                showMessage(controlMessage, err.message || 'Failed to update config / æ›´æ–°é…ç½®å¤±è´¥', true);
            }
        }

        async function updateLeverage() {
            try {
                const leverage = parseInt(document.getElementById('leverageInput').value || '1', 10);
                if (isNaN(leverage) || leverage < 1 || leverage > 125) {
                    showMessage(controlMessage, 'Invalid leverage value. Must be between 1 and 125. / æ— æ•ˆçš„æ æ†å€¼ã€‚å¿…é¡»åœ¨ 1 åˆ° 125 ä¹‹é—´ã€‚', true);
                    return;
                }
                
                // Use Hyperliquid-specific leverage endpoint / ä½¿ç”¨ Hyperliquid ç‰¹å®šæ æ†ç«¯ç‚¹
                const res = await diagnosticFetch('/api/hyperliquid/leverage', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(leverage),
                });
                const data = await res.json();
                if (data.error) throw new Error(data.error);
                
                // Use message from response if available, otherwise construct it
                // å¦‚æœå“åº”ä¸­æœ‰æ¶ˆæ¯åˆ™ä½¿ç”¨ï¼Œå¦åˆ™æ„é€ æ¶ˆæ¯
                const message = data.message || `Leverage updated to ${data.leverage || leverage}x / æ æ†å·²æ›´æ–°è‡³ ${data.leverage || leverage}x`;
                showMessage(controlMessage, message);
            } catch (err) {
                showMessage(controlMessage, err.message || 'Failed to update leverage / æ›´æ–°æ æ†å¤±è´¥', true);
            }
        }

        // Price update interval (30 seconds) - balanced to avoid excessive API calls while keeping prices fresh
        // ä»·æ ¼æ›´æ–°é—´éš”ï¼ˆ30ç§’ï¼‰- å¹³è¡¡é¿å…è¿‡å¤š API è°ƒç”¨ï¼ŒåŒæ—¶ä¿æŒä»·æ ¼æœ€æ–°
        const PRICE_UPDATE_INTERVAL = 30000; // 30 seconds / 30 ç§’
        let pairPrices = {}; // Cache for pair prices / äº¤æ˜“å¯¹ä»·æ ¼ç¼“å­˜
        
        // Update prices for all trading pairs in the dropdown / æ›´æ–°ä¸‹æ‹‰åˆ—è¡¨ä¸­æ‰€æœ‰äº¤æ˜“å¯¹çš„ä»·æ ¼
        async function updateAllPairPrices() {
            try {
                const pairSelect = document.getElementById('pairSelect');
                if (!pairSelect) return;
                
                // Get all symbols from options / ä»é€‰é¡¹ä¸­è·å–æ‰€æœ‰äº¤æ˜“å¯¹
                const symbols = Array.from(pairSelect.options).map(opt => opt.value);
                if (symbols.length === 0) return;
                
                // Fetch prices for all symbols at once / ä¸€æ¬¡æ€§è·å–æ‰€æœ‰äº¤æ˜“å¯¹çš„ä»·æ ¼
                const symbolsParam = symbols.map(s => encodeURIComponent(s)).join(',');
                const res = await diagnosticFetch(`/api/hyperliquid/prices?symbols=${symbolsParam}`);
                const data = await res.json();
                
                if (data.ok && data.prices) {
                    // Update cache / æ›´æ–°ç¼“å­˜
                    pairPrices = { ...pairPrices, ...data.prices };
                    
                    // Update option text with prices / ä½¿ç”¨ä»·æ ¼æ›´æ–°é€‰é¡¹æ–‡æœ¬
                    Array.from(pairSelect.options).forEach(option => {
                        const symbol = option.value;
                        const baseSymbol = symbol.split('/')[0]; // Extract base symbol (e.g., "ETH" from "ETH/USDC:USDC")
                        // Update data-price attribute / æ›´æ–° data-price å±æ€§
                        const price = data.prices[symbol];
                        
                        if (price !== null && price !== undefined && !isNaN(price)) {
                            option.textContent = `${symbol} ($${price.toFixed(2)})`;
                            // Update data-price attribute / æ›´æ–° data-price å±æ€§
                            option.setAttribute('data-price', price.toFixed(2));
                            // Store price in cache / å°†ä»·æ ¼å­˜å‚¨åœ¨ç¼“å­˜ä¸­
                            pairPrices[symbol] = price;
                        } else {
                            // If price not available, show cached price or "--" / å¦‚æœä»·æ ¼ä¸å¯ç”¨ï¼Œæ˜¾ç¤ºç¼“å­˜ä»·æ ¼æˆ– "--"
                            const cachedPrice = pairPrices[symbol];
                            if (cachedPrice !== null && cachedPrice !== undefined) {
                                option.textContent = `${symbol} ($${cachedPrice.toFixed(2)})`;
                                // Update data-price attribute with cached price / ä½¿ç”¨ç¼“å­˜ä»·æ ¼æ›´æ–° data-price å±æ€§
                                option.setAttribute('data-price', cachedPrice.toFixed(2));
                            } else {
                                option.textContent = `${symbol} (--)`;
                                // Clear data-price if no price available / å¦‚æœæ²¡æœ‰ä»·æ ¼åˆ™æ¸…é™¤ data-price
                                option.setAttribute('data-price', '');
                            }
                        }
                    });
                }
            } catch (err) {
                console.warn('Failed to update pair prices / æ›´æ–°äº¤æ˜“å¯¹ä»·æ ¼å¤±è´¥:', err);
                // On error, keep existing prices in options / å‡ºé”™æ—¶ï¼Œä¿æŒé€‰é¡¹ä¸­çš„ç°æœ‰ä»·æ ¼
            }
        }
        
        // Get price for a specific symbol (from cache or fetch) / è·å–ç‰¹å®šäº¤æ˜“å¯¹çš„ä»·æ ¼ï¼ˆä»ç¼“å­˜æˆ–è·å–ï¼‰
        async function getPairPrice(symbol) {
            // Check cache first / å…ˆæ£€æŸ¥ç¼“å­˜
            if (pairPrices[symbol] !== null && pairPrices[symbol] !== undefined) {
                return pairPrices[symbol];
            }
            
            // If not in cache, fetch it / å¦‚æœä¸åœ¨ç¼“å­˜ä¸­ï¼Œè·å–å®ƒ
            try {
                const symbolsParam = encodeURIComponent(symbol);
                const res = await diagnosticFetch(`/api/hyperliquid/prices?symbols=${symbolsParam}`);
                const data = await res.json();
                
                if (data.ok && data.prices && data.prices[symbol] !== null && data.prices[symbol] !== undefined) {
                    pairPrices[symbol] = data.prices[symbol];
                    return data.prices[symbol];
                }
            } catch (err) {
                console.warn(`Failed to fetch price for ${symbol} / è·å– ${symbol} ä»·æ ¼å¤±è´¥:`, err);
            }
            
            return null;
        }

        async function switchPair() {
            // Reset connection flag to allow checkConnection to run / é‡ç½®è¿æ¥æ ‡å¿—ä»¥å…è®¸ checkConnection è¿è¡Œ
            isCheckingConnection = false;
            // Mark that user manually switched pair / æ ‡è®°ç”¨æˆ·æ‰‹åŠ¨åˆ‡æ¢äº†äº¤æ˜“å¯¹
            userManuallySwitchedPair = true;
            try {
                const symbol = document.getElementById('pairSelect').value;
                
                // Immediately update price for the selected pair / ç«‹å³æ›´æ–°é€‰ä¸­äº¤æ˜“å¯¹çš„ä»·æ ¼
                await getPairPrice(symbol);
                
                // Use Hyperliquid-specific pair endpoint / ä½¿ç”¨ Hyperliquid ç‰¹å®šäº¤æ˜“å¯¹ç«¯ç‚¹
                const res = await diagnosticFetch('/api/hyperliquid/pair', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ symbol }),
                });
                const data = await res.json();
                
                // Check for error
                if (data.error) {
                    throw new Error(data.error);
                }
                
                // Update symbol
                currentEvalSymbol = normalizeSymbol(symbol);
                
                // Show success message, with warning if connection is needed
                if (data.warning) {
                    showMessage(controlMessage, `Switched to ${symbol} / å·²åˆ‡æ¢åˆ° ${symbol}. ${data.warning}`, false);
                } else {
                    showMessage(controlMessage, `Switched to ${symbol} / å·²åˆ‡æ¢åˆ° ${symbol}`);
                }
                
                // Refresh connection status to show new pair price / åˆ·æ–°è¿æ¥çŠ¶æ€ä»¥æ˜¾ç¤ºæ–°äº¤æ˜“å¯¹ä»·æ ¼
                checkConnection();
                
                // Only refresh if connected
                if (data.status === 'updated' && !data.warning) {
                    loadStatus();
                    refreshPosition();
                    refreshOrders();
                }
            } catch (err) {
                showMessage(controlMessage, err.message || 'Failed to switch pair / åˆ‡æ¢äº¤æ˜“å¯¹å¤±è´¥', true);
            }
        }

        function getEvaluationSymbol() {
            const select = document.getElementById('pairSelect');
            // Return raw symbol format (e.g., "ETH/USDC:USDC") for evaluation API
            // The backend will handle symbol conversion for Hyperliquid
            // è¿”å›åŸå§‹ symbol æ ¼å¼ï¼ˆä¾‹å¦‚ï¼Œ"ETH/USDC:USDC"ï¼‰ç”¨äºè¯„ä¼° API
            // åç«¯ä¼šå¤„ç† Hyperliquid çš„ symbol è½¬æ¢
            if (select && select.value) {
                return select.value;  // Return original format / è¿”å›åŸå§‹æ ¼å¼
            }
            // Fallback: return default symbol in original format
            // å›é€€ï¼šè¿”å›é»˜è®¤ symbol çš„åŸå§‹æ ¼å¼
            return 'ETH/USDC:USDC';
        }

        function formatPercent(value, decimals = 1) {
            if (value === null || value === undefined || isNaN(value)) return '--';
            return `${(value * 100).toFixed(decimals)}%`;
        }

        function formatNumber(value, decimals = 2) {
            if (value === null || value === undefined || isNaN(value)) return '--';
            return Number(value).toFixed(decimals);
        }

        function formatCurrency(value) {
            if (value === null || value === undefined || isNaN(value)) return '--';
            return `$${Number(value).toFixed(2)}`;
        }

        // Progress display functions / è¿›åº¦æ˜¾ç¤ºå‡½æ•° (AC-11)
        const STEP_NAMES = [
            { en: 'Collecting Data', zh: 'æ”¶é›†æ•°æ®', icon: 'ğŸ“Š' },
            { en: 'Building Prompt', zh: 'æ•´ç† Prompt', icon: 'ğŸ“' },
            { en: 'Inferring', zh: 'æ¨ç†ä¸­', icon: 'ğŸ§ ' },
            { en: 'Parsing & Validating', zh: 'è§£æå¹¶éªŒè¯', icon: 'ğŸ”' },
            { en: 'Simulating', zh: 'æ¨¡æ‹Ÿä¸­', icon: 'ğŸ²' },
            { en: 'Scoring', zh: 'æ‰“åˆ†ä¸­', icon: 'ğŸ“ˆ' },
        ];

        function updateProgressDisplay() {
            const progressPanel = document.getElementById('evaluationProgressPanel');
            if (!progressPanel) return;

            if (!evaluationState.loading) {
                progressPanel.style.display = 'none';
                if (evaluationState.elapsedInterval) {
                    clearInterval(evaluationState.elapsedInterval);
                    evaluationState.elapsedInterval = null;
                }
                return;
            }

            progressPanel.style.display = 'block';

            // Update elapsed time / æ›´æ–°å·²ç”¨æ—¶é—´
            if (evaluationState.startTime) {
                const elapsed = Math.floor((Date.now() - evaluationState.startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                const elapsedText = document.getElementById('elapsedTimeText');
                if (elapsedText) {
                    elapsedText.innerText = `Elapsed: ${minutes}m ${seconds}s / å·²ç”¨æ—¶é—´: ${minutes}åˆ† ${seconds}ç§’`;
                }
            }

            // Update overall progress / æ›´æ–°æ€»ä½“è¿›åº¦
            const completedCount = Object.values(evaluationState.providerStatus).filter(s => s.status === 'completed' || s.status === 'failed').length;
            const totalCount = evaluationState.providers.length;
            const progressPercent = totalCount > 0 ? (completedCount / totalCount) * 100 : 0;

            const overallProgressText = document.getElementById('overallProgressText');
            const overallProgressPercent = document.getElementById('overallProgressPercent');
            const overallProgressBar = document.getElementById('overallProgressBar');
            const overallStatusText = document.getElementById('overallStatusText');
            const overallStatusIcon = document.getElementById('overallStatusIcon');

            if (overallProgressText) {
                overallProgressText.innerText = `${completedCount} / ${totalCount} providers completed / ${completedCount} / ${totalCount} ä¸ªæä¾›å•†å·²å®Œæˆ`;
            }
            if (overallProgressPercent) {
                overallProgressPercent.innerText = `${Math.round(progressPercent)}%`;
            }
            if (overallProgressBar) {
                overallProgressBar.style.width = `${progressPercent}%`;
            }

            if (completedCount === totalCount && totalCount > 0) {
                const hasFailed = Object.values(evaluationState.providerStatus).some(s => s.status === 'failed');
                if (hasFailed && completedCount === totalCount) {
                    if (overallStatusText) overallStatusText.innerText = 'Evaluation Failed / è¯„ä¼°å¤±è´¥';
                    if (overallStatusIcon) overallStatusIcon.innerText = 'âœ—';
                } else {
                    if (overallStatusText) overallStatusText.innerText = 'Evaluation Completed / è¯„ä¼°å·²å®Œæˆ';
                    if (overallStatusIcon) overallStatusIcon.innerText = 'âœ“';
                }
            } else {
                if (overallStatusText) overallStatusText.innerText = 'Evaluation in Progress / è¯„ä¼°è¿›è¡Œä¸­';
                if (overallStatusIcon) overallStatusIcon.innerText = 'â³';
            }

            // Update provider status list / æ›´æ–°æä¾›å•†çŠ¶æ€åˆ—è¡¨
            const providerList = document.getElementById('providerStatusList');
            if (providerList) {
                providerList.innerHTML = evaluationState.providers.map(providerName => {
                    const status = evaluationState.providerStatus[providerName] || { status: 'pending', step: 0, stepProgress: 0 };
                    const isActive = status.status === 'in_progress';
                    const isCompleted = status.status === 'completed';
                    const isFailed = status.status === 'failed';

                    let statusClass = 'provider-status-item';
                    if (isActive) statusClass += ' active';
                    else if (isCompleted) statusClass += ' completed';
                    else if (isFailed) statusClass += ' failed';

                    let stepIndicator = '';
                    let statusText = '';
                    let progressBar = '';
                    let elapsedTime = '';

                    if (status.status === 'completed') {
                        stepIndicator = `<span class="step-indicator completed">âœ“ Completed / å·²å®Œæˆ</span>`;
                        statusText = 'Completed / å·²å®Œæˆ';
                        if (status.completedAt) {
                            const elapsed = Math.floor((status.completedAt - evaluationState.startTime) / 1000);
                            elapsedTime = `<div style="font-size:11px; color:#6b7280; margin-top:4px;">Completed in ${elapsed}s / å®Œæˆäº ${elapsed}ç§’</div>`;
                        }
                    } else if (status.status === 'failed') {
                        stepIndicator = `<span class="step-indicator failed">âœ— Failed / å¤±è´¥</span>`;
                        statusText = status.error || 'Failed / å¤±è´¥';
                        if (status.failedAt) {
                            const elapsed = Math.floor((status.failedAt - evaluationState.startTime) / 1000);
                            elapsedTime = `<div style="font-size:11px; color:#6b7280; margin-top:4px;">Failed in ${elapsed}s / å¤±è´¥äº ${elapsed}ç§’</div>`;
                        }
                    } else if (status.status === 'in_progress') {
                        const stepInfo = STEP_NAMES[status.step] || STEP_NAMES[0];
                        stepIndicator = `<span class="step-indicator active">Step ${status.step + 1}/6: ${stepInfo.en} / æ­¥éª¤ ${status.step + 1}/6: ${stepInfo.zh}</span>`;
                        statusText = `${stepInfo.icon} ${stepInfo.en}... / ${stepInfo.zh}...`;

                        // Show progress bar for simulating step / ä¸ºæ¨¡æ‹Ÿæ­¥éª¤æ˜¾ç¤ºè¿›åº¦æ¡
                        if (status.step === 4) { // Simulating step
                            const simProgress = status.stepProgress || 0;
                            progressBar = `
                                <div style="margin-top:8px;">
                                    <div style="font-size:11px; color:#6b7280; margin-bottom:2px;">
                                        Simulating: ${simProgress}/500 steps (${Math.round(simProgress / 5)}%) / æ¨¡æ‹Ÿä¸­: ${simProgress}/500 æ­¥ (${Math.round(simProgress / 5)}%)
                                    </div>
                                    <div class="individual-progress-bar">
                                        <div class="individual-progress-bar-fill" style="width:${(simProgress / 500) * 100}%;"></div>
                                    </div>
                                </div>
                            `;
                        }
                    } else {
                        stepIndicator = `<span class="step-indicator">â¸ Pending / ç­‰å¾…ä¸­</span>`;
                        statusText = 'Waiting... / ç­‰å¾…ä¸­...';
                    }

                    return `
                        <div class="${statusClass}">
                            <div style="display:flex; justify-content:space-between; align-items:center;">
                                <div style="font-weight:bold; font-size:13px;">${providerName}</div>
                                ${stepIndicator}
                            </div>
                            <div style="font-size:12px; color:#6b7280; margin-top:4px;">${statusText}</div>
                            ${progressBar}
                            ${elapsedTime}
                        </div>
                    `;
                }).join('');
            }
        }

        function simulateProgress() {
            // Simulate progress for each provider / ä¸ºæ¯ä¸ªæä¾›å•†æ¨¡æ‹Ÿè¿›åº¦
            evaluationState.providers.forEach((providerName, index) => {
                if (!evaluationState.providerStatus[providerName]) {
                    evaluationState.providerStatus[providerName] = { status: 'pending', step: 0, stepProgress: 0 };
                }

                const status = evaluationState.providerStatus[providerName];
                if (status.status === 'pending' || status.status === 'in_progress') {
                    // Simulate step progression / æ¨¡æ‹Ÿæ­¥éª¤è¿›å±•
                    const delay = index * 2000; // Stagger providers / é”™å¼€æä¾›å•†
                    setTimeout(() => {
                        status.status = 'in_progress';
                        updateProgressDisplay();

                        // Simulate each step / æ¨¡æ‹Ÿæ¯ä¸ªæ­¥éª¤
                        STEP_NAMES.forEach((_, stepIndex) => {
                            setTimeout(() => {
                                status.step = stepIndex;
                                if (stepIndex === 4) { // Simulating step
                                    // Simulate simulation progress / æ¨¡æ‹Ÿæ¨¡æ‹Ÿè¿›åº¦
                                    let simProgress = 0;
                                    const simInterval = setInterval(() => {
                                        simProgress += 50;
                                        status.stepProgress = Math.min(simProgress, 500);
                                        updateProgressDisplay();
                                        if (simProgress >= 500) {
                                            clearInterval(simInterval);
                                        }
                                    }, 200);
                                    setTimeout(() => clearInterval(simInterval), 10000);
                                }
                                updateProgressDisplay();
                            }, stepIndex * 1500 + delay);
                        });

                        // Mark as completed after all steps / æ‰€æœ‰æ­¥éª¤åæ ‡è®°ä¸ºå®Œæˆ
                        setTimeout(() => {
                            status.status = 'completed';
                            status.completedAt = Date.now();
                            updateProgressDisplay();
                        }, STEP_NAMES.length * 1500 + delay + 1000);
                    }, delay);
                }
            });
        }

        function updateEvaluationUI() {
            const statusEl = document.getElementById('evaluationStatusText');
            const runBtn = document.getElementById('runEvaluationBtn');
            const errorBox = document.getElementById('evaluationErrorBox');
            const consensusCard = document.getElementById('evaluationConsensusCard');
            const resultsWrapper = document.getElementById('evaluationResultsWrapper');
            const resultsBody = document.getElementById('evaluationResultsBody');
            const lastRunEl = document.getElementById('evaluationLastRun');

            if (runBtn) runBtn.disabled = evaluationState.loading;
            if (evaluationState.loading) {
                statusEl.innerText = 'Running evaluation... Please wait. / æ­£åœ¨è¿è¡Œè¯„ä¼°... è¯·ç¨å€™ã€‚';
            } else if (evaluationState.lastRunAt) {
                statusEl.innerText = `Last run: ${evaluationState.lastRunSymbol} @ ${new Date(evaluationState.lastRunAt).toLocaleTimeString()} / ä¸Šæ¬¡è¿è¡Œ: ${evaluationState.lastRunSymbol} @ ${new Date(evaluationState.lastRunAt).toLocaleTimeString()}`;
            } else {
                statusEl.innerText = 'Ready. / å°±ç»ªã€‚';
            }

            if (evaluationState.lastError) {
                errorBox.style.display = 'block';
                errorBox.innerText = evaluationState.lastError;
            } else {
                errorBox.style.display = 'none';
            }

            // Update progress display / æ›´æ–°è¿›åº¦æ˜¾ç¤º
            updateProgressDisplay();

            // Map strategy names to bilingual display / å°†ç­–ç•¥åç§°æ˜ å°„åˆ°åŒè¯­æ˜¾ç¤º
            function getBilingualStrategyName(strategy) {
                const strategyMap = {
                    'FixedSpread': 'Fixed Spread / å›ºå®šä»·å·®',
                    'FundingRate': 'Funding Rate / èµ„é‡‘è´¹ç‡',
                    'fixed_spread': 'Fixed Spread / å›ºå®šä»·å·®',
                    'funding_rate': 'Funding Rate / èµ„é‡‘è´¹ç‡',
                };
                return strategyMap[strategy] || strategy || '--';
            }

            if (consensusCard) {
                const aggregated = evaluationState.aggregated;
                if (aggregated && aggregated.consensus_proposal && aggregated.strategy_consensus) {
                    const proposal = aggregated.consensus_proposal;
                    consensusCard.style.display = 'block';
                    
                    // Display strategy name in bilingual format / ä»¥åŒè¯­æ ¼å¼æ˜¾ç¤ºç­–ç•¥åç§°
                    const strategyName = getBilingualStrategyName(proposal.recommended_strategy);
                    document.getElementById('evaluationConsensusStrategy').innerText = strategyName;
                    
                    // Display parameters in bilingual format / ä»¥åŒè¯­æ ¼å¼æ˜¾ç¤ºå‚æ•°
                    document.getElementById('evaluationConsensusParams').innerText =
                        `${formatPercent(proposal.spread || 0, 2)} Â· Qty ${formatNumber(proposal.quantity || 0, 3)} Â· Lev ${formatNumber(proposal.leverage || 0, 1)}x`;
                    
                    // Display reasoning, or show default message if empty
                    // æ˜¾ç¤ºæ¨ç†ï¼Œå¦‚æœä¸ºç©ºåˆ™æ˜¾ç¤ºé»˜è®¤æ¶ˆæ¯
                    const reasoning = proposal.reasoning && proposal.reasoning.trim() 
                        ? proposal.reasoning 
                        : 'Consensus reasoning unavailable. / å…±è¯†æ¨ç†ä¸å¯ç”¨ã€‚';
                    document.getElementById('evaluationConsensusReasoning').innerText = reasoning;
                    
                    // Display stats in bilingual format / ä»¥åŒè¯­æ ¼å¼æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
                    document.getElementById('evaluationConsensusStats').innerText =
                        `Avg PnL / å¹³å‡ç›ˆäº ${formatCurrency(aggregated.avg_pnl || 0)} Â· Avg Sharpe / å¹³å‡å¤æ™® ${formatNumber(aggregated.avg_sharpe || 0, 2)} Â· Avg Win / å¹³å‡èƒœç‡ ${formatPercent(aggregated.avg_win_rate || 0, 1)}`;
                } else {
                    consensusCard.style.display = 'none';
                }
            }

            if (resultsWrapper) {
                if (evaluationState.results.length > 0) {
                    resultsWrapper.style.display = 'block';
                    lastRunEl.innerText = evaluationState.lastRunAt
                        ? `Updated ${new Date(evaluationState.lastRunAt).toLocaleTimeString()} / æ›´æ–°äº ${new Date(evaluationState.lastRunAt).toLocaleTimeString()}`
                        : '';
                    const rows = evaluationState.results.map((result) => {
                        const proposal = result.proposal || {};
                        const simulation = result.simulation || {};
                        const disabledApply = !proposal.parse_success ? 'disabled' : '';
                        const providerSafe = (result.provider_name || '').replace(/"/g, '&quot;');
                        const highlight = result.rank === 1 ? 'style="background:#fef3c7;"' : '';
                        return `
                            <tr ${highlight}>
                                <td>${result.rank ?? '--'}</td>
                                <td>${result.provider_name || '--'}</td>
                                <td>${getBilingualStrategyName(proposal.recommended_strategy)}</td>
                                <td>${formatPercent(proposal.spread || 0, 2)}</td>
                                <td>${formatNumber(proposal.quantity || 0, 3)}</td>
                                <td>${formatNumber(proposal.leverage || 0, 1)}x</td>
                                <td>${formatPercent(proposal.confidence || 0, 1)}</td>
                                <td>${formatCurrency(simulation.realized_pnl)}</td>
                                <td>${formatNumber(simulation.sharpe_ratio || 0, 2)}</td>
                                <td>${formatPercent(simulation.win_rate || 0, 1)}</td>
                                <td>${formatNumber(result.score || 0, 1)}</td>
                                <td><button class="btn btn-secondary" style="font-size:11px;" ${disabledApply}
                                    onclick="applyEvaluation('individual', '${providerSafe}')">Apply</button></td>
                            </tr>`;
                    }).join('');
                    resultsBody.innerHTML = rows;
                } else {
                    resultsWrapper.style.display = 'none';
                    lastRunEl.innerText = '';
                }
            }
        }

        // Get selected LLM models / è·å–é€‰ä¸­çš„ LLM æ¨¡å‹
        function getSelectedModels() {
            const checkboxes = document.querySelectorAll('.llm-model-checkbox:checked');
            const selectedModels = Array.from(checkboxes).map(cb => cb.value);
            return selectedModels;
        }

        // Update selected models hint / æ›´æ–°é€‰ä¸­æ¨¡å‹æç¤º
        function updateSelectedModelsHint() {
            const selectedModels = getSelectedModels();
            const hintEl = document.getElementById('selectedModelsHint');
            if (!hintEl) return;
            
            if (selectedModels.length === 0) {
                hintEl.innerText = 'âš ï¸ Please select at least one model / è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªæ¨¡å‹';
                hintEl.style.color = '#dc2626';
            } else {
                const modelNames = selectedModels.map(m => {
                    if (m === 'gemini') return 'Gemini';
                    if (m === 'openai') return 'OpenAI';
                    if (m === 'claude') return 'Claude';
                    return m;
                }).join(', ');
                hintEl.innerText = `Selected: ${modelNames} / å·²é€‰æ‹©: ${modelNames}`;
                hintEl.style.color = '#6b7280';
            }
        }

        async function runEvaluation() {
            if (evaluationState.loading) return;
            
            // Get selected models / è·å–é€‰ä¸­çš„æ¨¡å‹
            const selectedModels = getSelectedModels();
            if (selectedModels.length === 0) {
                const errorBox = document.getElementById('evaluationErrorBox');
                if (errorBox) {
                    errorBox.style.display = 'block';
                    errorBox.innerText = 'Please select at least one LLM model / è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ª LLM æ¨¡å‹';
                }
                return;
            }
            
            evaluationState.loading = true;
            evaluationState.lastError = null;
            evaluationState.startTime = Date.now();
            evaluationState.providerStatus = {};
            
            // Map selected models to provider names / å°†é€‰ä¸­çš„æ¨¡å‹æ˜ å°„åˆ°æä¾›å•†åç§°
            const modelToProviderName = {
                'gemini': 'Gemini',
                'openai': 'OpenAI',
                'claude': 'Claude'
            };
            evaluationState.providers = selectedModels.map(m => modelToProviderName[m] || m);
            
            // Initialize provider status / åˆå§‹åŒ–æä¾›å•†çŠ¶æ€
            evaluationState.providers.forEach(name => {
                evaluationState.providerStatus[name] = { status: 'pending', step: 0, stepProgress: 0 };
            });

            // Start elapsed time counter / å¯åŠ¨å·²ç”¨æ—¶é—´è®¡æ•°å™¨
            if (evaluationState.elapsedInterval) clearInterval(evaluationState.elapsedInterval);
            evaluationState.elapsedInterval = setInterval(() => {
                updateProgressDisplay();
            }, 1000);

            updateEvaluationUI();
            simulateProgress(); // Start progress simulation / å¯åŠ¨è¿›åº¦æ¨¡æ‹Ÿ

            try {
                const res = await diagnosticFetch('/api/evaluation/run', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        symbol: getEvaluationSymbol(),
                        exchange: 'hyperliquid',  // Always use hyperliquid exchange
                        simulation_steps: 500,
                        selected_models: selectedModels  // Send selected models to backend / å‘é€é€‰ä¸­çš„æ¨¡å‹åˆ°åç«¯
                    }),
                });
                const data = await res.json();
                if (data.error) throw new Error(data.error);
                
                // Mark all providers as completed / æ ‡è®°æ‰€æœ‰æä¾›å•†ä¸ºå·²å®Œæˆ
                evaluationState.providers.forEach(name => {
                    if (evaluationState.providerStatus[name].status !== 'failed') {
                        evaluationState.providerStatus[name].status = 'completed';
                        evaluationState.providerStatus[name].completedAt = Date.now();
                    }
                });

                evaluationState.results = data.individual_results || [];
                evaluationState.aggregated = data.aggregated || null;
                evaluationState.lastRunSymbol = data.symbol || getEvaluationSymbol();
                evaluationState.lastRunAt = new Date().toISOString();
                
                // Check for parse errors in individual results / æ£€æŸ¥å•ä¸ªç»“æœä¸­çš„è§£æé”™è¯¯
                const errorBox = document.getElementById('evaluationErrorBox');
                const parseErrors = [];
                if (evaluationState.results && evaluationState.results.length > 0) {
                    evaluationState.results.forEach(result => {
                        if (result.proposal && result.proposal.parse_error && result.proposal.parse_error.trim()) {
                            parseErrors.push({
                                provider: result.provider_name || 'Unknown',
                                error: result.proposal.parse_error
                            });
                        }
                    });
                }
                
                // Display parse errors if any / å¦‚æœæœ‰è§£æé”™è¯¯åˆ™æ˜¾ç¤º
                if (parseErrors.length > 0) {
                    const errorMessages = parseErrors.map(err => 
                        `${err.provider}: ${err.error}`
                    ).join('\n');
                    const errorMessage = `LLM Parse Errors / LLM è§£æé”™è¯¯:\n${errorMessages}`;
                    evaluationState.lastError = errorMessage;
                    
                    // Use error handler to display formatted error / ä½¿ç”¨é”™è¯¯å¤„ç†å™¨æ˜¾ç¤ºæ ¼å¼åŒ–çš„é”™è¯¯
                    if (errorBox && typeof handleApiError === 'function') {
                        handleApiError({
                            error_type: 'llm_parse_error',
                            message: `LLM parsing failed for ${parseErrors.length} model(s) / ${parseErrors.length} ä¸ªæ¨¡å‹è§£æå¤±è´¥`,
                            message_zh: `${parseErrors.length} ä¸ªæ¨¡å‹è§£æå¤±è´¥`,
                            severity: 'warning',
                            suggestion: 'The evaluation completed but some models failed to parse their responses. You can still use the successfully parsed results. / è¯„ä¼°å·²å®Œæˆï¼Œä½†æŸäº›æ¨¡å‹æœªèƒ½è§£æå…¶å“åº”ã€‚æ‚¨ä»å¯ä»¥ä½¿ç”¨æˆåŠŸè§£æçš„ç»“æœã€‚',
                            suggestion_zh: 'è¯„ä¼°å·²å®Œæˆï¼Œä½†æŸäº›æ¨¡å‹æœªèƒ½è§£æå…¶å“åº”ã€‚æ‚¨ä»å¯ä»¥ä½¿ç”¨æˆåŠŸè§£æçš„ç»“æœã€‚',
                            details: {
                                parse_errors: parseErrors,
                                total_errors: parseErrors.length,
                                total_results: evaluationState.results.length
                            }
                        }, errorBox, { showDetails: true });
                    } else if (errorBox) {
                        // Fallback to simple display / å›é€€åˆ°ç®€å•æ˜¾ç¤º
                        errorBox.innerText = errorMessage;
                        errorBox.style.display = 'block';
                    }
                } else {
                    // Clear error if no parse errors / å¦‚æœæ²¡æœ‰è§£æé”™è¯¯åˆ™æ¸…é™¤é”™è¯¯
                    evaluationState.lastError = null;
                    if (errorBox && typeof clearError === 'function') {
                        clearError(errorBox);
                    } else if (errorBox) {
                        errorBox.style.display = 'none';
                    }
                }
            } catch (err) {
                // Mark all providers as failed / æ ‡è®°æ‰€æœ‰æä¾›å•†ä¸ºå¤±è´¥
                evaluationState.providers.forEach(name => {
                    evaluationState.providerStatus[name].status = 'failed';
                    evaluationState.providerStatus[name].failedAt = Date.now();
                    evaluationState.providerStatus[name].error = err.message;
                });
                evaluationState.lastError = err.message || 'Failed to run evaluation / è¿è¡Œè¯„ä¼°å¤±è´¥';
            } finally {
                evaluationState.loading = false;
                updateEvaluationUI();
                if (evaluationState.elapsedInterval) {
                    clearInterval(evaluationState.elapsedInterval);
                    evaluationState.elapsedInterval = null;
                }
            }
        }

        async function applyEvaluation(source, providerName = null) {
            try {
                const payload = { 
                    source,
                    exchange: 'hyperliquid'  // Always use hyperliquid exchange
                };
                if (providerName) payload.provider_name = providerName;
                const res = await diagnosticFetch('/api/evaluation/apply', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                const data = await res.json();
                if (data.error) throw new Error(data.error);
                
                // Update input fields with applied config / ä½¿ç”¨åº”ç”¨çš„é…ç½®æ›´æ–°è¾“å…¥æ¡†
                if (data.applied_config) {
                    const config = data.applied_config;
                    // Update spread input (convert from decimal to percentage) / æ›´æ–°ä»·å·®è¾“å…¥ï¼ˆä»å°æ•°è½¬æ¢ä¸ºç™¾åˆ†æ¯”ï¼‰
                    if (config.spread !== undefined) {
                        const spreadInput = document.getElementById('spreadInput');
                        if (spreadInput) {
                            spreadInput.value = (config.spread * 100).toFixed(2);
                        }
                    }
                    // Update quantity input / æ›´æ–°æ•°é‡è¾“å…¥
                    if (config.quantity !== undefined) {
                        const quantityInput = document.getElementById('quantityInput');
                        if (quantityInput) {
                            quantityInput.value = config.quantity;
                        }
                    }
                    // Update leverage input / æ›´æ–°æ æ†è¾“å…¥
                    if (config.leverage !== undefined) {
                        const leverageInput = document.getElementById('leverageInput');
                        if (leverageInput) {
                            leverageInput.value = config.leverage;
                        }
                    }
                }
                
                showMessage(controlMessage, data.message || 'Applied evaluation proposal. / å·²åº”ç”¨è¯„ä¼°å»ºè®®ã€‚');
                loadStatus(); // Also refresh status to ensure consistency / åŒæ—¶åˆ·æ–°çŠ¶æ€ä»¥ç¡®ä¿ä¸€è‡´æ€§
            } catch (err) {
                showMessage(controlMessage, err.message || 'Failed to apply proposal / åº”ç”¨å»ºè®®å¤±è´¥', true);
            }
        }

        async function startBotWithLLMSuggestion() {
            try {
                await applyEvaluation('consensus');
                const res = await diagnosticFetch('/api/control?action=start', {
                    method: 'POST',
                });
                const data = await res.json();
                if (data.error) throw new Error(data.error);
                showMessage(controlMessage, 'âœ… Bot started with LLM suggestion! / Bot å·²ä½¿ç”¨ LLM å»ºè®®å¯åŠ¨ï¼');
                updateBotControlButtons(true); // Update button states / æ›´æ–°æŒ‰é’®çŠ¶æ€
                setTimeout(refreshOrders, 1000);
            } catch (err) {
                showMessage(controlMessage, err.message || 'Failed to start bot / å¯åŠ¨ Bot å¤±è´¥', true);
            }
        }

        async function stopBot() {
            try {
                const res = await diagnosticFetch('/api/control?action=stop', {
                    method: 'POST',
                });
                const data = await res.json();
                if (data.error) throw new Error(data.error);
                showMessage(controlMessage, 'âœ… Bot stopped. / Bot å·²åœæ­¢ã€‚');
                updateBotControlButtons(false); // Update button states / æ›´æ–°æŒ‰é’®çŠ¶æ€
                setTimeout(refreshOrders, 1000);
            } catch (err) {
                showMessage(controlMessage, err.message || 'Failed to stop bot / åœæ­¢ Bot å¤±è´¥', true);
            }
        }

        // Update bot control buttons based on bot status / æ ¹æ® bot çŠ¶æ€æ›´æ–°æ§åˆ¶æŒ‰é’®
        function updateBotControlButtons(isRunning) {
            const startBtn = document.getElementById('startBotBtn');
            const stopBtn = document.getElementById('stopBotBtn');
            
            if (isRunning) {
                // Bot is running: show stop button, hide start button / Bot æ­£åœ¨è¿è¡Œï¼šæ˜¾ç¤ºåœæ­¢æŒ‰é’®ï¼Œéšè—å¯åŠ¨æŒ‰é’®
                if (startBtn) startBtn.style.display = 'none';
                if (stopBtn) stopBtn.style.display = 'flex';
            } else {
                // Bot is stopped: show start button, hide stop button / Bot å·²åœæ­¢ï¼šæ˜¾ç¤ºå¯åŠ¨æŒ‰é’®ï¼Œéšè—åœæ­¢æŒ‰é’®
                if (startBtn) startBtn.style.display = 'flex';
                if (stopBtn) stopBtn.style.display = 'none';
            }
        }

        // Initialize button state on page load (default to stopped) / é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–æŒ‰é’®çŠ¶æ€ï¼ˆé»˜è®¤ä¸ºåœæ­¢ï¼‰
        function initializeBotButtons() {
            // Default to showing start button if status check fails / å¦‚æœçŠ¶æ€æ£€æŸ¥å¤±è´¥ï¼Œé»˜è®¤æ˜¾ç¤ºå¯åŠ¨æŒ‰é’®
            const startBtn = document.getElementById('startBotBtn');
            if (startBtn && startBtn.style.display === 'none' && !document.getElementById('stopBotBtn')?.style.display) {
                startBtn.style.display = 'flex';
            }
        }

        async function refreshOrders() {
            // Prevent duplicate requests / é˜²æ­¢é‡å¤è¯·æ±‚
            if (isRefreshingOrders) return;
            isRefreshingOrders = true;
            
            try {
                const statusEl = document.getElementById('ordersStatusText');
                const tableWrapper = document.getElementById('ordersTableWrapper');
                const tableBody = document.getElementById('ordersTableBody');
                const emptyMessage = document.getElementById('ordersEmptyMessage');
                
                if (statusEl) {
                    statusEl.innerText = 'Loading orders... / æ­£åœ¨åŠ è½½è®¢å•...';
                    statusEl.classList.remove('error');
                }
                
                // Get Hyperliquid-specific status / è·å– Hyperliquid ç‰¹å®šçŠ¶æ€
                const res = await diagnosticFetch('/api/hyperliquid/status');
                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                }
                const data = await res.json();
                
                if (data.error) {
                    if (tableWrapper) tableWrapper.style.display = 'none';
                    if (emptyMessage) emptyMessage.style.display = 'block';
                    if (statusEl) {
                        statusEl.innerText = data.error;
                        statusEl.classList.add('error');
                    }
                    return;
                }
                
                const orders = data.orders || [];
                
                if (orders.length === 0) {
                    if (tableWrapper) tableWrapper.style.display = 'none';
                    if (emptyMessage) emptyMessage.style.display = 'block';
                    if (statusEl) {
                        statusEl.innerText = 'No active orders / æ— æ´»è·ƒè®¢å•';
                        statusEl.classList.remove('error');
                    }
                } else {
                    if (tableWrapper) tableWrapper.style.display = 'block';
                    if (emptyMessage) emptyMessage.style.display = 'none';
                    if (statusEl) {
                        statusEl.innerText = `Found ${orders.length} active order(s) / æ‰¾åˆ° ${orders.length} ä¸ªæ´»è·ƒè®¢å•`;
                        statusEl.classList.remove('error');
                    }
                    
                    if (tableBody) {
                        const rows = orders.map(order => {
                            const orderId = order.id || order.orderId || order.oid || '--';
                            const side = order.side || (order.sz > 0 ? 'BUY' : 'SELL') || '--';
                            const price = formatNumber(order.price || order.limitPx || 0, 4);
                            const quantity = formatNumber(Math.abs(order.amount || order.sz || order.quantity || 0), 4);
                            const status = order.status || order.status || 'open';
                            const timestamp = order.timestamp ? new Date(order.timestamp).toLocaleTimeString() : '--';
                            
                            const sideColor = side.toLowerCase() === 'buy' ? '#22c55e' : '#ef4444';
                            const safeOrderId = String(orderId).replace(/'/g, "\\'");
                            
                            return `
                                <tr>
                                    <td style="font-family:monospace; font-size:11px;">${String(orderId).substring(0, 20)}${String(orderId).length > 20 ? '...' : ''}</td>
                                    <td><span style="color:${sideColor}; font-weight:bold;">${side.toUpperCase()}</span></td>
                                    <td>${price}</td>
                                    <td>${quantity}</td>
                                    <td><span style="padding:2px 6px; border-radius:4px; background:#e5e7eb; font-size:11px;">${status}</span></td>
                                    <td style="font-size:11px; color:#6b7280;">${timestamp}</td>
                                    <td><button class="btn btn-danger" style="font-size:11px; padding:4px 8px;" onclick="cancelOrder('${safeOrderId}')">Cancel</button></td>
                                </tr>`;
                        }).join('');
                        
                        tableBody.innerHTML = rows;
                    }
                }
            } catch (err) {
                const statusEl = document.getElementById('ordersStatusText');
                if (statusEl) {
                    statusEl.innerText = `Error loading orders: ${err.message} / åŠ è½½è®¢å•é”™è¯¯: ${err.message}`;
                    statusEl.classList.add('error');
                }
                const tableWrapper = document.getElementById('ordersTableWrapper');
                const emptyMessage = document.getElementById('ordersEmptyMessage');
                if (tableWrapper) tableWrapper.style.display = 'none';
                if (emptyMessage) emptyMessage.style.display = 'block';
            } finally {
                isRefreshingOrders = false;
            }
        }

        async function cancelOrder(orderId) {
            try {
                if (!orderId || orderId === '--') {
                    showMessage(controlMessage, 'Invalid order ID / æ— æ•ˆçš„è®¢å• ID', true);
                    return;
                }
                
                // Use Hyperliquid-specific cancel order endpoint / ä½¿ç”¨ Hyperliquid ç‰¹å®šå–æ¶ˆè®¢å•ç«¯ç‚¹
                const res = await diagnosticFetch('/api/hyperliquid/cancel-order', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(orderId),
                });
                const data = await res.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                showMessage(controlMessage, data.message || `Order ${orderId} canceled / è®¢å• ${orderId} å·²å–æ¶ˆ`);
                
                // Refresh orders after cancellation / å–æ¶ˆååˆ·æ–°è®¢å•
                setTimeout(refreshOrders, 500);
            } catch (err) {
                showMessage(controlMessage, err.message || 'Failed to cancel order / å–æ¶ˆè®¢å•å¤±è´¥', true);
            }
        }

        // Auto-refresh - Track intervals for cleanup
        // è‡ªåŠ¨åˆ·æ–° - è·Ÿè¸ªé—´éš”ä»¥ä¾¿æ¸…ç†
        let ordersRefreshInterval = null;
        let positionRefreshInterval = null;
        let connectionRefreshInterval = null;
        
        function startAutoRefresh() {
            if (ordersRefreshInterval) clearInterval(ordersRefreshInterval);
            if (positionRefreshInterval) clearInterval(positionRefreshInterval);
            if (connectionRefreshInterval) clearInterval(connectionRefreshInterval);
            
            // Initial load
            refreshOrders();
            refreshPosition();
            checkConnection();
            
            // Reduced refresh intervals to avoid rate limiting (429 errors)
            // å‡å°‘åˆ·æ–°é—´éš”ä»¥é¿å…é€Ÿç‡é™åˆ¶ï¼ˆ429 é”™è¯¯ï¼‰
            ordersRefreshInterval = setInterval(refreshOrders, 15000);  // 15 seconds (was 3)
            positionRefreshInterval = setInterval(refreshPosition, 20000);  // 20 seconds (was 5)
            connectionRefreshInterval = setInterval(checkConnection, 30000);  // 30 seconds (was 10)
        }

        // Suppress Chrome extension runtime.lastError messages
        // These errors are caused by browser extensions trying to communicate
        // and don't affect page functionality
        // æŠ‘åˆ¶ Chrome æ‰©å±• runtime.lastError æ¶ˆæ¯
        // è¿™äº›é”™è¯¯æ˜¯ç”±æµè§ˆå™¨æ‰©å±•å°è¯•é€šä¿¡å¼•èµ·çš„ï¼Œä¸å½±å“é¡µé¢åŠŸèƒ½
        const originalError = console.error;
        console.error = function(...args) {
            // Filter out Chrome extension runtime.lastError messages
            // è¿‡æ»¤æ‰ Chrome æ‰©å±• runtime.lastError æ¶ˆæ¯
            if (args.length > 0 && typeof args[0] === 'string' && 
                (args[0].includes('runtime.lastError') || 
                 args[0].includes('Could not establish connection') ||
                 args[0].includes('Receiving end does not exist'))) {
                return; // Suppress this error
            }
            originalError.apply(console, args);
        };

        // Initialize checkbox event listeners / åˆå§‹åŒ– checkbox äº‹ä»¶ç›‘å¬å™¨
        function initModelCheckboxes() {
            const checkboxes = document.querySelectorAll('.llm-model-checkbox');
            checkboxes.forEach(cb => {
                cb.addEventListener('change', updateSelectedModelsHint);
            });
            updateSelectedModelsHint();
        }

        document.addEventListener('DOMContentLoaded', () => {
            initModelCheckboxes();  // Initialize model selection checkboxes / åˆå§‹åŒ–æ¨¡å‹é€‰æ‹©å¤é€‰æ¡†
            initializeBotButtons(); // Initialize button states / åˆå§‹åŒ–æŒ‰é’®çŠ¶æ€
            loadStatus(); // This will update button states based on actual bot status / è¿™å°†æ ¹æ®å®é™… bot çŠ¶æ€æ›´æ–°æŒ‰é’®çŠ¶æ€
            updateEvaluationUI();
            checkConnection();
            refreshPosition();
            refreshOrders();
            startAutoRefresh();
            
            // Initialize Error History Panel / åˆå§‹åŒ–é”™è¯¯å†å²é¢æ¿
            if (window.ErrorHistoryPanel) {
                new ErrorHistoryPanel('errorHistoryPanel', {
                    refreshInterval: 30000, // 30 seconds / 30 ç§’
                    autoRefresh: true
                });
            }
            
            // Load initial pair prices in dropdown / åœ¨ä¸‹æ‹‰åˆ—è¡¨ä¸­åŠ è½½åˆå§‹äº¤æ˜“å¯¹ä»·æ ¼
            updateAllPairPrices();
            
            // Set up periodic price updates (balanced frequency to avoid excessive API calls) / è®¾ç½®å®šæœŸä»·æ ¼æ›´æ–°ï¼ˆå¹³è¡¡é¢‘ç‡ä»¥é¿å…è¿‡å¤š API è°ƒç”¨ï¼‰
            setInterval(updateAllPairPrices, PRICE_UPDATE_INTERVAL);
            
            // Also update connection status periodically to refresh selected pair price / å®šæœŸæ›´æ–°è¿æ¥çŠ¶æ€ä»¥åˆ·æ–°é€‰ä¸­äº¤æ˜“å¯¹ä»·æ ¼
            // This is already handled by checkConnection interval, but we ensure it uses the selected pair / è¿™å·²ç»ç”± checkConnection é—´éš”å¤„ç†ï¼Œä½†æˆ‘ä»¬ç¡®ä¿å®ƒä½¿ç”¨é€‰ä¸­çš„äº¤æ˜“å¯¹
        });
    </script>
</body>

</html>


