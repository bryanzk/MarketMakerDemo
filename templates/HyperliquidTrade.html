<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Hyperliquid Trading Page / Hyperliquid ‰∫§ÊòìÈ°µÈù¢</title>
    <style>
        body {
            margin: 0;
            font-family: "Inter", "PingFang SC", sans-serif;
            background: #f5f5fa;
            color: #1f2937;
        }

        a {
            color: #3b82f6;
            text-decoration: none;
        }

        .page {
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }

        .panel {
            background: #ffffff;
            border-radius: 14px;
            box-shadow: 0 8px 30px rgba(15, 23, 42, 0.08);
            padding: 24px;
            margin-bottom: 24px;
        }

        .panel h2 {
            margin: 0 0 16px;
            font-size: 20px;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 16px;
        }

        label {
            font-size: 13px;
            color: #6b7280;
            display: block;
            margin-bottom: 6px;
        }

        input,
        select {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
            background: #f9fafb;
            font-size: 14px;
            box-sizing: border-box;
        }

        .btn {
            border: none;
            border-radius: 8px;
            padding: 10px 16px;
            font-size: 14px;
            cursor: pointer;
        }

        .btn-primary {
            background: #4f46e5;
            color: #fff;
        }

        .btn-secondary {
            background: #e5e7eb;
            color: #374151;
        }

        .btn-success {
            background: #22c55e;
            color: #fff;
        }

        .btn-danger {
            background: #ef4444;
            color: #fff;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        table th,
        table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #f3f4f6;
        }

        .message {
            margin-top: 12px;
            font-size: 13px;
        }

        .message.error {
            color: #b91c1c;
        }

        .message.success {
            color: #059669;
        }

        .consensus-card {
            border: 1px dashed #c4b5fd;
            padding: 12px;
            border-radius: 10px;
            background: #f5f3ff;
            margin-top: 16px;
        }

        .nav-link {
            font-size: 14px;
            padding: 8px 14px;
            border-radius: 999px;
            background: #eef2ff;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .status-connected {
            background: #d1fae5;
            color: #065f46;
        }

        .status-disconnected {
            background: #fee2e2;
            color: #991b1b;
        }

        .info-card {
            background: #f0f9ff;
            border: 1px solid #bae6fd;
            padding: 12px;
            border-radius: 8px;
            margin-top: 12px;
        }
    </style>
    <!-- Error handling styles / ÈîôËØØÂ§ÑÁêÜÊ†∑Âºè -->
    <link rel="stylesheet" href="/static/error_styles.css">
    <link rel="stylesheet" href="/static/debug_panel.css">
    <link rel="stylesheet" href="/static/validation.css">
    <link rel="stylesheet" href="/static/error_history.css">
    <!-- API Diagnostics and Error Handler / API ËØäÊñ≠ÂíåÈîôËØØÂ§ÑÁêÜ -->
    <script src="/static/api_diagnostics.js"></script>
    <script src="/static/error_handler.js"></script>
    <script src="/static/debug_panel.js"></script>
    <script src="/static/validation.js"></script>
    <script src="/static/error_history.js"></script>
</head>

<body>
    <div class="page">
        <header>
            <div>
                <h1 style="margin:0;">Hyperliquid Trading Page / Hyperliquid ‰∫§ÊòìÈ°µÈù¢</h1>
                <div style="font-size:13px; color:#6b7280;">Dedicated interface for Hyperliquid exchange trading / ‰∏ìÁî® Hyperliquid ‰∫§ÊòìÊâÄ‰∫§ÊòìÁïåÈù¢</div>
            </div>
            <div style="display:flex; gap:12px; align-items:center;">
                <span id="connectionStatus" class="status-badge status-disconnected">Checking...</span>
                <a class="nav-link" href="/">‚Üê Back to Dashboard</a>
            </div>
        </header>

        <!-- Connection Status Panel / ËøûÊé•Áä∂ÊÄÅÈù¢Êùø -->
        <section class="panel">
            <h2>Connection Status / ËøûÊé•Áä∂ÊÄÅ</h2>
            <div id="connectionInfo" class="info-card">
                <div>Exchange: <strong>Hyperliquid</strong></div>
                <div id="connectionDetails" style="margin-top:8px; font-size:13px; color:#6b7280; display:none;"></div>
            </div>
        </section>

        <!-- Position and Balance Panel / ‰ªì‰Ωç‰∏é‰ΩôÈ¢ùÈù¢Êùø -->
        <section class="panel">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <h2 style="margin:0;">Position & Balance / ‰ªì‰Ωç‰∏é‰ΩôÈ¢ù</h2>
                <button class="btn btn-secondary" onclick="refreshPosition()">üîÑ Refresh</button>
            </div>
            <div id="positionStatus" class="message" style="color:#6b7280; margin-top:12px;">Loading position data...</div>
            <div id="positionData" style="display:none; margin-top:16px;">
                <div class="grid">
                    <div>
                        <label>Total Balance / ÊÄª‰ΩôÈ¢ù</label>
                        <div style="font-size:20px; font-weight:bold;" id="totalBalance">--</div>
                    </div>
                    <div>
                        <label>Available Balance / ÂèØÁî®‰ΩôÈ¢ù</label>
                        <div style="font-size:20px; font-weight:bold;" id="availableBalance">--</div>
                    </div>
                    <div>
                        <label>Position Amount / ‰ªì‰ΩçÊï∞Èáè</label>
                        <div style="font-size:20px; font-weight:bold;" id="positionAmount">--</div>
                    </div>
                    <div>
                        <label>Unrealized PnL / Êú™ÂÆûÁé∞Áõà‰∫è</label>
                        <div style="font-size:20px; font-weight:bold;" id="unrealizedPnL">--</div>
                    </div>
                </div>
                <div style="margin-top:16px;">
                    <h3 style="font-size:14px; margin-bottom:8px;">Open Positions / Êú™Âπ≥‰ªì</h3>
                    <div id="positionsTable" style="overflow-x:auto;">
                        <table>
                            <thead>
                                <tr style="background:#f3f4f6;">
                                    <th>Symbol / ‰∫§ÊòìÂØπ</th>
                                    <th>Side / ÊñπÂêë</th>
                                    <th>Size / Êï∞Èáè</th>
                                    <th>Entry Price / ÂÖ•Âú∫‰ª∑</th>
                                    <th>Mark Price / Ê†áËÆ∞‰ª∑</th>
                                    <th>PnL / Áõà‰∫è</th>
                                </tr>
                            </thead>
                            <tbody id="positionsTableBody">
                                <tr><td colspan="6" style="text-align:center; color:#6b7280;">No open positions / Êó†Êú™Âπ≥‰ªì</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </section>

        <!-- Strategy Control Panel / Á≠ñÁï•ÊéßÂà∂Èù¢Êùø -->
        <section class="panel">
            <h2>Fixed Spread Strategy Control Panel / Âõ∫ÂÆö‰ª∑Â∑ÆÁ≠ñÁï•ÊéßÂà∂Èù¢Êùø</h2>
            <div class="grid">
                <div>
                    <label>Trading Pair / ‰∫§ÊòìÂØπ</label>
                    <select id="pairSelect" onchange="switchPair()">
                        <option value="ETH/USDT:USDT" data-price="">ETH/USDT:USDT</option>
                        <option value="BTC/USDT:USDT" data-price="">BTC/USDT:USDT</option>
                        <option value="SOL/USDT:USDT" data-price="">SOL/USDT:USDT</option>
                    </select>
                </div>
            </div>
            <div class="grid" style="margin-top: 16px;">
                <div>
                    <label>Spread (%) / ‰ª∑Â∑Æ (%)</label>
                    <input type="number" id="spreadInput" step="0.01" value="1.5">
                </div>
                <div>
                    <label>Quantity / Êï∞Èáè</label>
                    <input type="number" id="quantityInput" step="0.01" value="0.1">
                </div>
                <div>
                    <label>Leverage / Êù†ÊùÜ</label>
                    <input type="number" id="leverageInput" min="1" max="125" value="5">
                </div>
            </div>
            <div style="display:flex; gap:12px; margin-top:16px;">
                <button class="btn btn-primary" onclick="updateConfig()">üíæ Save Strategy Config</button>
                <button class="btn btn-secondary" onclick="updateLeverage()">‚ö° Update Leverage</button>
            </div>
            <div id="controlMessage" class="message"></div>
        </section>

        <!-- LLM Evaluation Panel / LLM ËØÑ‰º∞Èù¢Êùø -->
        <section class="panel">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <div>
                    <h2 style="margin:0;">Multi-LLM Evaluation / Â§öÊ®°ÂûãËØÑ‰º∞</h2>
                    <div style="font-size:13px; color:#6b7280;">Gemini ¬∑ OpenAI ¬∑ Claude (Hyperliquid Context)</div>
                </div>
                <button id="runEvaluationBtn" class="btn btn-primary" onclick="runEvaluation()">üöÄ Run Evaluation</button>
            </div>
            <div id="evaluationStatusText" class="message" style="color:#6b7280; margin-top:12px;">Ready.</div>
            <div id="evaluationErrorBox" class="message error" style="display:none;"></div>

            <div id="evaluationConsensusCard" class="consensus-card" style="display:none;">
                <div style="font-size:14px; font-weight:bold; color:#6d28d9;">ü§ù Consensus Recommendation / ÂÖ±ËØÜÂª∫ËÆÆ</div>
                <div style="margin-top:8px; font-size:13px;">
                    <div>Strategy: <span id="evaluationConsensusStrategy" style="font-weight:bold;">--</span></div>
                    <div>Spread / Skew / Qty / Lev:
                        <span id="evaluationConsensusParams" style="font-weight:bold;">--</span>
                    </div>
                </div>
                <div id="evaluationConsensusStats" style="margin-top:6px; font-size:12px; color:#4b5563;">--</div>
                <div id="evaluationConsensusReasoning" style="margin-top:8px; font-size:12px; color:#6b7280;">--</div>
                <div style="display:flex; gap:8px; margin-top:12px;">
                    <button class="btn btn-success" style="flex:1;"
                        onclick="applyEvaluation('consensus')">Apply Consensus</button>
                    <button class="btn btn-primary" style="flex:1;"
                        onclick="startBotWithLLMSuggestion()">üöÄ Start Bot</button>
                </div>
            </div>

            <div id="evaluationResultsWrapper" style="margin-top:20px; display:none;">
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <div style="font-size:13px; font-weight:bold;">Model Comparison / Ê®°ÂûãÂØπÊØî</div>
                    <div id="evaluationLastRun" style="font-size:11px; color:#6b7280;"></div>
                </div>
                <div style="overflow-x:auto; margin-top:8px;">
                    <table>
                        <thead>
                            <tr style="background:#f3f4f6;">
                                <th>Rank</th>
                                <th>Provider</th>
                                <th>Strategy</th>
                                <th>Spread</th>
                                <th>Skew</th>
                                <th>Qty</th>
                                <th>Lev</th>
                                <th>Confidence</th>
                                <th>PnL</th>
                                <th>Sharpe</th>
                                <th>Win%</th>
                                <th>Score</th>
                                <th></th>
                            </tr>
                        </thead>
                        <tbody id="evaluationResultsBody"></tbody>
                    </table>
                </div>
            </div>
        </section>

        <!-- Orders Panel / ËÆ¢ÂçïÈù¢Êùø -->
        <section class="panel">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <div>
                    <h2 style="margin:0;">Current Orders / ÂΩìÂâçËÆ¢Âçï</h2>
                    <div style="font-size:13px; color:#6b7280;">Real-time order status</div>
                </div>
                <button class="btn btn-secondary" onclick="refreshOrders()">üîÑ Refresh</button>
            </div>
            <div id="ordersStatusText" class="message" style="color:#6b7280; margin-top:12px;">Loading orders...</div>
            <div id="ordersTableWrapper" style="margin-top:16px; display:none;">
                <div style="overflow-x:auto;">
                    <table>
                        <thead>
                            <tr style="background:#f3f4f6;">
                                <th>Order ID</th>
                                <th>Side</th>
                                <th>Price</th>
                                <th>Quantity</th>
                                <th>Status</th>
                                <th>Time</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody id="ordersTableBody"></tbody>
                    </table>
                </div>
                <div id="ordersEmptyMessage" style="text-align:center; padding:24px; color:#6b7280; display:none;">
                    No active orders / Êó†Ê¥ªË∑ÉËÆ¢Âçï
                </div>
            </div>
        </section>

        <!-- Error History Panel / ÈîôËØØÂéÜÂè≤Èù¢Êùø -->
        <section class="panel">
            <div id="errorHistoryPanel"></div>
        </section>
    </div>

    <script>
        const controlMessage = document.getElementById('controlMessage');
        let currentEvalSymbol = 'ETHUSDT';
        let userManuallySwitchedPair = false; // Track if user manually switched pair / Ë∑üË∏™Áî®Êà∑ÊòØÂê¶ÊâãÂä®ÂàáÊç¢‰∫§ÊòìÂØπ
        let evaluationState = {
            loading: false,
            results: [],
            aggregated: null,
            lastError: null,
            lastRunSymbol: null,
            lastRunAt: null,
        };

        function showMessage(el, text, isError = false) {
            if (!el) return;
            el.innerText = text;
            el.classList.toggle('error', isError);
            el.classList.toggle('success', !isError);
        }

        function normalizeSymbol(symbol) {
            if (!symbol) return 'ETHUSDT';
            return symbol.toUpperCase().replace(/[:\/-]/g, '');
        }

        // Connection Status / ËøûÊé•Áä∂ÊÄÅ
        async function checkConnection() {
            // Request deduplication / ËØ∑Ê±ÇÂéªÈáç
            if (isCheckingConnection) {
                return;
            }
            isCheckingConnection = true;
            
            const errorBox = document.getElementById('evaluationErrorBox');
            clearError(errorBox);
            
            try {
                // Get Hyperliquid status directly (faster than evaluation API)
                // Áõ¥Êé•Ëé∑Âèñ Hyperliquid Áä∂ÊÄÅÔºàÊØîËØÑ‰º∞ API Êõ¥Âø´Ôºâ
                const res = await diagnosticFetch('/api/hyperliquid/status');
                const data = await res.json();
                
                const statusEl = document.getElementById('connectionStatus');
                const detailsEl = document.getElementById('connectionDetails');
                const networkEl = document.getElementById('networkBadge');
                const networkTextEl = document.getElementById('networkText');
                
                // Ensure elements exist before updating
                // Á°Æ‰øùÂÖÉÁ¥†Â≠òÂú®ÂêéÂÜçÊõ¥Êñ∞
                if (!statusEl || !detailsEl) {
                    console.error('Connection status elements not found');
                    return;
                }
                
                // Check for rate limit error / Ê£ÄÊü•ÈÄüÁéáÈôêÂà∂ÈîôËØØ
                const isRateLimit = data.error_type === 'rate_limit' || 
                                   data.error_code === 'RATE_LIMIT_EXCEEDED' ||
                                   (data.error && (data.error.includes('429') || data.error.includes('Rate limit') || data.error.includes('ÈÄüÁéáÈôêÂà∂')));
                
                if (isRateLimit) {
                    // Display rate limit error in status badge / Âú®Áä∂ÊÄÅÂæΩÁ´†‰∏≠ÊòæÁ§∫ÈÄüÁéáÈôêÂà∂ÈîôËØØ
                    statusEl.className = 'status-badge status-disconnected';
                    statusEl.innerText = 'APIË∞ÉÁî®Ë∂ÖÂá∫ÈÄüÁéáÈôêÂà∂';
                    detailsEl.style.display = 'none';
                    if (networkEl) {
                        networkEl.style.display = 'none';
                    }
                    // Don't show error in error box for rate limits / ‰∏çÂú®ÈîôËØØÊ°Ü‰∏≠ÊòæÁ§∫ÈÄüÁéáÈôêÂà∂ÈîôËØØ
                } else if (data.error || !data.ok || !data.connected) {
                    handleApiError(data, errorBox);
                    statusEl.className = 'status-badge status-disconnected';
                    statusEl.innerText = 'Disconnected / Êú™ËøûÊé•';
                    detailsEl.style.display = 'none';
                    if (networkEl) {
                        networkEl.style.display = 'none';
                    }
                } else {
                    statusEl.className = 'status-badge status-connected';
                    statusEl.innerText = 'Connected / Â∑≤ËøûÊé•';
                    
                    // Update network badge (Mainnet/Testnet)
                    // Êõ¥Êñ∞ÁΩëÁªúÂæΩÁ´†Ôºà‰∏ªÁΩë/ÊµãËØïÁΩëÔºâ
                    if (networkEl && networkTextEl) {
                        networkEl.style.display = 'inline-block';
                        if (data.testnet) {
                            networkEl.className = 'network-badge testnet';
                            networkTextEl.innerText = '‚ö†Ô∏è TESTNET';
                        } else {
                            networkEl.className = 'network-badge mainnet';
                            networkTextEl.innerText = '‚úì MAINNET';
                        }
                    }
                    
                    // Hide connection details / ÈöêËóèËøûÊé•ËØ¶ÊÉÖ
                    detailsEl.style.display = 'none';
                }
            } catch (err) {
                console.error('checkConnection error:', err);
                
                // Check if error is rate limit related / Ê£ÄÊü•ÈîôËØØÊòØÂê¶‰∏éÈÄüÁéáÈôêÂà∂Áõ∏ÂÖ≥
                const isRateLimit = err.message && (
                    err.message.includes('429') || 
                    err.message.includes('Rate limit') || 
                    err.message.includes('ÈÄüÁéáÈôêÂà∂')
                );
                
                if (!isRateLimit) {
                    displayError(err, errorBox);
                }
                
                const statusEl = document.getElementById('connectionStatus');
                const detailsEl = document.getElementById('connectionDetails');
                if (statusEl) {
                    if (isRateLimit) {
                        statusEl.className = 'status-badge status-disconnected';
                        statusEl.innerText = 'APIË∞ÉÁî®Ë∂ÖÂá∫ÈÄüÁéáÈôêÂà∂';
                    } else {
                        statusEl.className = 'status-badge status-disconnected';
                        statusEl.innerText = 'Error / ÈîôËØØ';
                    }
                }
                if (detailsEl) {
                    detailsEl.style.display = 'none';
                }
            } finally {
                isCheckingConnection = false;
            }
        }

        // Position and Balance / ‰ªì‰Ωç‰∏é‰ΩôÈ¢ù
        async function refreshPosition() {
            // Request deduplication / ËØ∑Ê±ÇÂéªÈáç
            if (isRefreshingPosition) {
                return;
            }
            isRefreshingPosition = true;
            
            const errorBox = document.getElementById('evaluationErrorBox');
            clearError(errorBox);
            
            try {
                const statusEl = document.getElementById('positionStatus');
                statusEl.innerText = 'Loading position data...';
                
                // Get status which should include position info
                const res = await diagnosticFetch('/api/hyperliquid/status');
                const data = await res.json();
                
                const positionData = document.getElementById('positionData');
                const totalBalanceEl = document.getElementById('totalBalance');
                const availableBalanceEl = document.getElementById('availableBalance');
                const positionAmountEl = document.getElementById('positionAmount');
                const unrealizedPnLEl = document.getElementById('unrealizedPnL');
                
                if (data.balance !== undefined) {
                    positionData.style.display = 'block';
                    totalBalanceEl.innerText = `$${data.balance.toFixed(2)}`;
                    availableBalanceEl.innerText = `$${(data.balance - (data.position || 0) * (data.mid_price || 0)).toFixed(2)}`;
                    positionAmountEl.innerText = `${(data.position || 0).toFixed(4)}`;
                    unrealizedPnLEl.innerText = `$${((data.unrealized_pnl || 0)).toFixed(2)}`;
                    statusEl.innerText = 'Position data loaded / ‰ªì‰ΩçÊï∞ÊçÆÂ∑≤Âä†ËΩΩ';
                } else {
                    positionData.style.display = 'none';
                    statusEl.innerText = 'Position data not available / ‰ªì‰ΩçÊï∞ÊçÆ‰∏çÂèØÁî®';
                }
            } catch (err) {
                displayError(err, errorBox);
                const statusEl = document.getElementById('positionStatus');
                statusEl.innerText = `Error: ${err.message}`;
                statusEl.classList.add('error');
            } finally {
                isRefreshingPosition = false;
            }
        }

        async function loadStatus() {
            const errorBox = document.getElementById('evaluationErrorBox');
            clearError(errorBox);
            
            try {
                // Use Hyperliquid-specific status endpoint / ‰ΩøÁî® Hyperliquid ÁâπÂÆöÁä∂ÊÄÅÁ´ØÁÇπ
                const res = await diagnosticFetch('/api/hyperliquid/status');
                const data = await res.json();
                
                if (data.error || !data.ok) {
                    handleApiError(data, errorBox);
                    return;
                }
                if (data.spread !== undefined) {
                    document.getElementById('spreadInput').value = (data.spread * 100).toFixed(3);
                }
                document.getElementById('quantityInput').value = data.quantity ?? 0.1;
                document.getElementById('leverageInput').value = data.leverage ?? 5;
                currentEvalSymbol = normalizeSymbol(data.symbol);

                // Only update pairSelect if user hasn't manually switched / ‰ªÖÂú®Áî®Êà∑Êú™ÊâãÂä®ÂàáÊç¢Êó∂Êõ¥Êñ∞ pairSelect
                const pairSelect = document.getElementById('pairSelect');
                if (pairSelect && data.symbol && !userManuallySwitchedPair) {
                    for (const option of pairSelect.options) {
                        if (option.value.toUpperCase() === data.symbol.toUpperCase()) {
                            pairSelect.value = option.value;
                            break;
                        }
                    }
                }
            } catch (err) {
                displayError(err, errorBox);
                showMessage(controlMessage, `Failed to load status: ${err.message}`, true);
            }
        }

        async function updateConfig() {
            const errorBox = document.getElementById('evaluationErrorBox');
            clearError(errorBox);
            clearValidationErrors(errorBox);
            
            // Validate inputs / È™åËØÅËæìÂÖ•
            const spread = parseFloat(document.getElementById('spreadInput').value || '0');
            const quantity = parseFloat(document.getElementById('quantityInput').value || '0');
            
            const validation = validateOrder({
                spread: spread,
                quantity: quantity
            });
            
            if (!validation.valid) {
                displayValidationErrors(validation, errorBox);
                return;
            }
            
            try {
                const payload = {
                    spread: spread,
                    quantity: quantity,
                    strategy_type: 'fixed_spread',
                    strategy_id: 'default',
                };
                const res = await diagnosticFetch('/api/hyperliquid/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                const data = await res.json();
                if (data.error || !data.ok) {
                    handleApiError(data, errorBox);
                    return;
                }
                showMessage(controlMessage, 'Strategy config updated. / Á≠ñÁï•ÈÖçÁΩÆÂ∑≤Êõ¥Êñ∞„ÄÇ');
            } catch (err) {
                displayError(err, errorBox);
                showMessage(controlMessage, err.message || 'Failed to update config / Êõ¥Êñ∞ÈÖçÁΩÆÂ§±Ë¥•', true);
            }
        }

        async function updateLeverage() {
            const errorBox = document.getElementById('evaluationErrorBox');
            clearError(errorBox);
            clearValidationErrors(errorBox);
            
            // Validate leverage / È™åËØÅÊù†ÊùÜ
            const leverage = parseInt(document.getElementById('leverageInput').value || '1', 10);
            const validation = validateLeverage(leverage);
            
            if (!validation.valid) {
                displayValidationErrors(validation, errorBox);
                return;
            }
            
            try {
                const res = await diagnosticFetch('/api/hyperliquid/leverage', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(leverage),
                });
                const data = await res.json();
                if (data.error || !data.ok) {
                    handleApiError(data, errorBox);
                    return;
                }
                showMessage(controlMessage, `Leverage updated to ${data.leverage}x / Êù†ÊùÜÂ∑≤Êõ¥Êñ∞Ëá≥ ${data.leverage}x`);
            } catch (err) {
                displayError(err, errorBox);
                showMessage(controlMessage, err.message || 'Failed to update leverage / Êõ¥Êñ∞Êù†ÊùÜÂ§±Ë¥•', true);
            }
        }

        async function switchPair() {
            const errorBox = document.getElementById('evaluationErrorBox');
            clearError(errorBox);
            clearValidationErrors(errorBox);
            
            // Validate symbol / È™åËØÅ‰∫§ÊòìÂØπ
            const symbol = document.getElementById('pairSelect').value;
            const validation = validateSymbol(symbol);
            
            if (!validation.valid) {
                displayValidationErrors(validation, errorBox);
                return;
            }
            
            try {
                // Mark that user manually switched pair / Ê†áËÆ∞Áî®Êà∑ÊâãÂä®ÂàáÊç¢‰∫Ü‰∫§ÊòìÂØπ
                userManuallySwitchedPair = true;
                
                const res = await diagnosticFetch('/api/hyperliquid/pair', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ symbol }),
                });
                const data = await res.json();
                if (data.error || !data.ok) {
                    handleApiError(data, errorBox);
                    userManuallySwitchedPair = false; // Reset on error / ÈîôËØØÊó∂ÈáçÁΩÆ
                    return;
                }
                currentEvalSymbol = normalizeSymbol(symbol);
                showMessage(controlMessage, `Switched to ${symbol} / Â∑≤ÂàáÊç¢Âà∞ ${symbol}`);
                
                // Wait longer for backend to update symbol and fetch new market data / Á≠âÂæÖÊõ¥ÈïøÊó∂Èó¥ËÆ©ÂêéÁ´ØÊõ¥Êñ∞‰∫§ÊòìÂØπÂπ∂Ëé∑ÂèñÊñ∞ÁöÑÂ∏ÇÂú∫Êï∞ÊçÆ
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Force refresh connection status to get updated price / Âº∫Âà∂Âà∑Êñ∞ËøûÊé•Áä∂ÊÄÅ‰ª•Ëé∑ÂèñÊõ¥Êñ∞ÁöÑ‰ª∑Ê†º
                // Clear the checking flag to ensure checkConnection runs / Ê∏ÖÈô§Ê£ÄÊü•Ê†áÂøó‰ª•Á°Æ‰øù checkConnection ËøêË°å
                isCheckingConnection = false;
                await checkConnection();
                
                // Wait a bit more to ensure market data is fetched / ÂÜçÁ≠âÂæÖ‰∏Ä‰∏ãÁ°Æ‰øùÂ∏ÇÂú∫Êï∞ÊçÆÂ∑≤Ëé∑Âèñ
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // Refresh connection status again to ensure we have the latest data / ÂÜçÊ¨°Âà∑Êñ∞ËøûÊé•Áä∂ÊÄÅ‰ª•Á°Æ‰øùÊúâÊúÄÊñ∞Êï∞ÊçÆ
                isCheckingConnection = false;
                await checkConnection();
                
                // Auto-refresh all data after switching pair / ÂàáÊç¢‰∫§ÊòìÂØπÂêéËá™Âä®Âà∑Êñ∞ÊâÄÊúâÊï∞ÊçÆ
                await loadStatus();
                refreshPosition();
                refreshOrders();
            } catch (err) {
                displayError(err, errorBox);
                showMessage(controlMessage, err.message || 'Failed to switch pair / ÂàáÊç¢‰∫§ÊòìÂØπÂ§±Ë¥•', true);
                userManuallySwitchedPair = false; // Reset on error / ÈîôËØØÊó∂ÈáçÁΩÆ
            }
        }

        function getEvaluationSymbol() {
            const select = document.getElementById('pairSelect');
            const raw = select && select.value ? select.value : currentEvalSymbol;
            return normalizeSymbol(raw);
        }

        function formatPercent(value, decimals = 1) {
            if (value === null || value === undefined || isNaN(value)) return '--';
            return `${(value * 100).toFixed(decimals)}%`;
        }

        function formatNumber(value, decimals = 2) {
            if (value === null || value === undefined || isNaN(value)) return '--';
            return Number(value).toFixed(decimals);
        }

        function formatCurrency(value) {
            if (value === null || value === undefined || isNaN(value)) return '--';
            return `$${Number(value).toFixed(2)}`;
        }

        function updateEvaluationUI() {
            const statusEl = document.getElementById('evaluationStatusText');
            const runBtn = document.getElementById('runEvaluationBtn');
            const errorBox = document.getElementById('evaluationErrorBox');
            const consensusCard = document.getElementById('evaluationConsensusCard');
            const resultsWrapper = document.getElementById('evaluationResultsWrapper');
            const resultsBody = document.getElementById('evaluationResultsBody');
            const lastRunEl = document.getElementById('evaluationLastRun');

            if (runBtn) runBtn.disabled = evaluationState.loading;
            if (evaluationState.loading) {
                statusEl.innerText = 'Running evaluation... Please wait. / Ê≠£Âú®ËøêË°åËØÑ‰º∞... ËØ∑Á®çÂÄô„ÄÇ';
            } else if (evaluationState.lastRunAt) {
                statusEl.innerText = `Last run: ${evaluationState.lastRunSymbol} @ ${new Date(evaluationState.lastRunAt).toLocaleTimeString()} / ‰∏äÊ¨°ËøêË°å: ${evaluationState.lastRunSymbol} @ ${new Date(evaluationState.lastRunAt).toLocaleTimeString()}`;
            } else {
                statusEl.innerText = 'Ready. / Â∞±Áª™„ÄÇ';
            }

            if (evaluationState.lastError) {
                errorBox.style.display = 'block';
                errorBox.innerText = evaluationState.lastError;
            } else {
                errorBox.style.display = 'none';
            }

            if (consensusCard) {
                const aggregated = evaluationState.aggregated;
                if (aggregated && aggregated.consensus_proposal && aggregated.strategy_consensus) {
                    const proposal = aggregated.consensus_proposal;
                    consensusCard.style.display = 'block';
                    document.getElementById('evaluationConsensusStrategy').innerText = proposal.recommended_strategy || '--';
                    document.getElementById('evaluationConsensusParams').innerText =
                        `${formatPercent(proposal.spread || 0, 2)} ¬∑ Skew ${formatNumber(proposal.skew_factor || 0, 0)} ¬∑ Qty ${formatNumber(proposal.quantity || 0, 3)} ¬∑ Lev ${formatNumber(proposal.leverage || 0, 1)}x`;
                    document.getElementById('evaluationConsensusReasoning').innerText =
                        proposal.reasoning || 'Consensus reasoning unavailable. / ÂÖ±ËØÜÊé®ÁêÜ‰∏çÂèØÁî®„ÄÇ';
                    document.getElementById('evaluationConsensusStats').innerText =
                        `Avg PnL ${formatCurrency(aggregated.avg_pnl || 0)} ¬∑ Avg Sharpe ${formatNumber(aggregated.avg_sharpe || 0, 2)} ¬∑ Avg Win ${formatPercent(aggregated.avg_win_rate || 0, 1)}`;
                } else {
                    consensusCard.style.display = 'none';
                }
            }

            if (resultsWrapper) {
                if (evaluationState.results.length > 0) {
                    resultsWrapper.style.display = 'block';
                    lastRunEl.innerText = evaluationState.lastRunAt
                        ? `Updated ${new Date(evaluationState.lastRunAt).toLocaleTimeString()} / Êõ¥Êñ∞‰∫é ${new Date(evaluationState.lastRunAt).toLocaleTimeString()}`
                        : '';
                    const rows = evaluationState.results.map((result) => {
                        const proposal = result.proposal || {};
                        const simulation = result.simulation || {};
                        const disabledApply = !proposal.parse_success ? 'disabled' : '';
                        const providerSafe = (result.provider_name || '').replace(/"/g, '&quot;');
                        const highlight = result.rank === 1 ? 'style="background:#fef3c7;"' : '';
                        return `
                            <tr ${highlight}>
                                <td>${result.rank ?? '--'}</td>
                                <td>${result.provider_name || '--'}</td>
                                <td>${proposal.recommended_strategy || '--'}</td>
                                <td>${formatPercent(proposal.spread || 0, 2)}</td>
                                <td>${formatNumber(proposal.skew_factor || 0, 0)}</td>
                                <td>${formatNumber(proposal.quantity || 0, 3)}</td>
                                <td>${formatNumber(proposal.leverage || 0, 1)}x</td>
                                <td>${formatPercent(proposal.confidence || 0, 1)}</td>
                                <td>${formatCurrency(simulation.realized_pnl)}</td>
                                <td>${formatNumber(simulation.sharpe_ratio || 0, 2)}</td>
                                <td>${formatPercent(simulation.win_rate || 0, 1)}</td>
                                <td>${formatNumber(result.score || 0, 1)}</td>
                                <td><button class="btn btn-secondary" style="font-size:11px;" ${disabledApply}
                                    onclick="applyEvaluation('individual', '${providerSafe}')">Apply</button></td>
                            </tr>`;
                    }).join('');
                    resultsBody.innerHTML = rows;
                } else {
                    resultsWrapper.style.display = 'none';
                    lastRunEl.innerText = '';
                }
            }
        }

        async function runEvaluation() {
            if (evaluationState.loading) return;
            const errorBox = document.getElementById('evaluationErrorBox');
            clearError(errorBox);
            
            evaluationState.loading = true;
            evaluationState.lastError = null;
            updateEvaluationUI();
            try {
                const res = await diagnosticFetch('/api/evaluation/run', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        symbol: getEvaluationSymbol(),
                        exchange: 'hyperliquid',  // Always use hyperliquid exchange
                        simulation_steps: 500
                    }),
                });
                const data = await res.json();
                if (data.error || !data.ok) {
                    handleApiError(data, errorBox);
                    evaluationState.lastError = data.message || data.error || 'Failed to run evaluation / ËøêË°åËØÑ‰º∞Â§±Ë¥•';
                } else {
                    evaluationState.results = data.individual_results || [];
                    evaluationState.aggregated = data.aggregated || null;
                    evaluationState.lastRunSymbol = data.symbol || getEvaluationSymbol();
                    evaluationState.lastRunAt = new Date().toISOString();
                }
            } catch (err) {
                displayError(err, errorBox);
                evaluationState.lastError = err.message || 'Failed to run evaluation / ËøêË°åËØÑ‰º∞Â§±Ë¥•';
            } finally {
                evaluationState.loading = false;
                updateEvaluationUI();
            }
        }

        async function applyEvaluation(source, providerName = null) {
            const errorBox = document.getElementById('evaluationErrorBox');
            clearError(errorBox);
            
            try {
                const payload = { 
                    source,
                    exchange: 'hyperliquid'  // Always use hyperliquid exchange
                };
                if (providerName) payload.provider_name = providerName;
                const res = await diagnosticFetch('/api/evaluation/apply', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                const data = await res.json();
                if (data.error || !data.ok) {
                    handleApiError(data, errorBox);
                    return;
                }
                showMessage(controlMessage, 'Applied evaluation proposal. / Â∑≤Â∫îÁî®ËØÑ‰º∞Âª∫ËÆÆ„ÄÇ');
                loadStatus();
            } catch (err) {
                displayError(err, errorBox);
                showMessage(controlMessage, err.message || 'Failed to apply proposal / Â∫îÁî®Âª∫ËÆÆÂ§±Ë¥•', true);
            }
        }

        async function startBotWithLLMSuggestion() {
            const errorBox = document.getElementById('evaluationErrorBox');
            clearError(errorBox);
            
            try {
                await applyEvaluation('consensus');
                const res = await diagnosticFetch('/api/control?action=start', {
                    method: 'POST',
                });
                const data = await res.json();
                if (data.error || !data.ok) {
                    handleApiError(data, errorBox);
                    return;
                }
                showMessage(controlMessage, '‚úÖ Bot started with LLM suggestion! / Bot Â∑≤‰ΩøÁî® LLM Âª∫ËÆÆÂêØÂä®ÔºÅ');
                setTimeout(refreshOrders, 1000);
            } catch (err) {
                displayError(err, errorBox);
                showMessage(controlMessage, err.message || 'Failed to start bot / ÂêØÂä® Bot Â§±Ë¥•', true);
            }
        }

        async function refreshOrders() {
            // Request deduplication / ËØ∑Ê±ÇÂéªÈáç
            if (isRefreshingOrders) {
                return;
            }
            isRefreshingOrders = true;
            
            const errorBox = document.getElementById('evaluationErrorBox');
            clearError(errorBox);
            
            try {
                const statusEl = document.getElementById('ordersStatusText');
                const tableWrapper = document.getElementById('ordersTableWrapper');
                const tableBody = document.getElementById('ordersTableBody');
                const emptyMessage = document.getElementById('ordersEmptyMessage');
                
                statusEl.innerText = 'Loading orders... / Ê≠£Âú®Âä†ËΩΩËÆ¢Âçï...';
                
                const res = await diagnosticFetch('/api/hyperliquid/status');
                const data = await res.json();
                
                if (data.error || !data.ok) {
                    handleApiError(data, errorBox);
                    return;
                }
                
                const orders = data.orders || [];
                
                if (orders.length === 0) {
                    tableWrapper.style.display = 'none';
                    emptyMessage.style.display = 'block';
                    statusEl.innerText = 'No active orders / Êó†Ê¥ªË∑ÉËÆ¢Âçï';
                } else {
                    tableWrapper.style.display = 'block';
                    emptyMessage.style.display = 'none';
                    statusEl.innerText = `Found ${orders.length} active order(s) / ÊâæÂà∞ ${orders.length} ‰∏™Ê¥ªË∑ÉËÆ¢Âçï`;
                    
                    const rows = orders.map(order => {
                        const orderId = order.id || order.orderId || '--';
                        const side = order.side || '--';
                        const price = formatNumber(order.price || 0, 4);
                        const quantity = formatNumber(order.amount || order.quantity || 0, 4);
                        const status = order.status || 'open';
                        const timestamp = order.timestamp ? new Date(order.timestamp).toLocaleTimeString() : '--';
                        
                        const sideColor = side.toLowerCase() === 'buy' ? '#22c55e' : '#ef4444';
                        
                        return `
                            <tr>
                                <td style="font-family:monospace; font-size:11px;">${orderId.substring(0, 20)}${orderId.length > 20 ? '...' : ''}</td>
                                <td><span style="color:${sideColor}; font-weight:bold;">${side.toUpperCase()}</span></td>
                                <td>${price}</td>
                                <td>${quantity}</td>
                                <td><span style="padding:2px 6px; border-radius:4px; background:#e5e7eb; font-size:11px;">${status}</span></td>
                                <td style="font-size:11px; color:#6b7280;">${timestamp}</td>
                                <td><button class="btn btn-danger" style="font-size:11px; padding:4px 8px;" onclick="cancelOrder('${orderId}')">Cancel</button></td>
                            </tr>`;
                    }).join('');
                    
                    tableBody.innerHTML = rows;
                }
            } catch (err) {
                displayError(err, errorBox);
                const statusEl = document.getElementById('ordersStatusText');
                statusEl.innerText = `Error loading orders: ${err.message} / Âä†ËΩΩËÆ¢ÂçïÈîôËØØ: ${err.message}`;
                statusEl.classList.add('error');
            } finally {
                isRefreshingOrders = false;
            }
        }

        async function cancelOrder(orderId) {
            const errorBox = document.getElementById('evaluationErrorBox');
            clearError(errorBox);
            
            try {
                const res = await diagnosticFetch('/api/hyperliquid/cancel-order', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ order_id: orderId }),
                });
                const data = await res.json();
                if (data.error || !data.ok) {
                    handleApiError(data, errorBox);
                    return;
                }
                showMessage(controlMessage, 'Order cancelled successfully. / ËÆ¢ÂçïÂ∑≤ÊàêÂäüÂèñÊ∂à„ÄÇ');
                setTimeout(refreshOrders, 500);
            } catch (err) {
                displayError(err, errorBox);
                showMessage(controlMessage, err.message || 'Failed to cancel order / ÂèñÊ∂àËÆ¢ÂçïÂ§±Ë¥•', true);
            }
        }

        // Request deduplication flags / ËØ∑Ê±ÇÂéªÈáçÊ†áÂøó
        let isRefreshingOrders = false;
        let isRefreshingPosition = false;
        let isCheckingConnection = false;
        
        // Auto-refresh
        let ordersRefreshInterval = null;
        let positionRefreshInterval = null;
        let connectionRefreshInterval = null;
        
        function startAutoRefresh() {
            if (ordersRefreshInterval) clearInterval(ordersRefreshInterval);
            if (positionRefreshInterval) clearInterval(positionRefreshInterval);
            if (connectionRefreshInterval) clearInterval(connectionRefreshInterval);
            
            refreshOrders();
            refreshPosition();
            checkConnection();
            
            // Increased intervals to reduce API calls and avoid rate limiting
            // Â¢ûÂä†Èó¥Èöî‰ª•ÂáèÂ∞ë API Ë∞ÉÁî®Âπ∂ÈÅøÂÖçÈÄüÁéáÈôêÂà∂
            ordersRefreshInterval = setInterval(refreshOrders, 10000);  // 10 seconds instead of 3
            positionRefreshInterval = setInterval(refreshPosition, 15000);  // 15 seconds instead of 5
            connectionRefreshInterval = setInterval(checkConnection, 30000);  // 30 seconds instead of 10
            
            // Update pair prices periodically / ÂÆöÊúüÊõ¥Êñ∞‰∫§ÊòìÂØπ‰ª∑Ê†º
            setInterval(updatePairPrices, 15000);  // Update every 15 seconds / ÊØè 15 ÁßíÊõ¥Êñ∞‰∏ÄÊ¨°
        }

        // Update pair prices in dropdown / Êõ¥Êñ∞‰∏ãÊãâÂàóË°®‰∏≠ÁöÑ‰∫§ÊòìÂØπ‰ª∑Ê†º
        async function updatePairPrices() {
            const pairSelect = document.getElementById('pairSelect');
            if (!pairSelect) return;
            
            // Get all symbols from options / ‰ªéÈÄâÈ°πËé∑ÂèñÊâÄÊúâ‰∫§ÊòìÂØπ
            const symbols = Array.from(pairSelect.options).map(opt => opt.value);
            
            try {
                const symbolsParam = symbols.join(',');
                const res = await diagnosticFetch(`/api/hyperliquid/prices?symbols=${encodeURIComponent(symbolsParam)}`);
                const data = await res.json();
                
                if (data.error || !data.ok || !data.prices) {
                    console.warn('Failed to fetch pair prices / Ëé∑Âèñ‰∫§ÊòìÂØπ‰ª∑Ê†ºÂ§±Ë¥•');
                    return;
                }
                
                // Update prices cache / Êõ¥Êñ∞‰ª∑Ê†ºÁºìÂ≠ò
                pairPrices = data.prices;
                
                // Update option text with prices / ‰ΩøÁî®‰ª∑Ê†ºÊõ¥Êñ∞ÈÄâÈ°πÊñáÊú¨
                Array.from(pairSelect.options).forEach(option => {
                    const symbol = option.value;
                    const price = pairPrices[symbol];
                    if (price !== null && price !== undefined) {
                        const priceStr = `$${price.toFixed(2)}`;
                        option.textContent = `${symbol} (${priceStr})`;
                        option.setAttribute('data-price', priceStr);
                    } else {
                        // Keep original text if price not available / Â¶ÇÊûú‰ª∑Ê†º‰∏çÂèØÁî®Ôºå‰øùÊåÅÂéüÂßãÊñáÊú¨
                        if (!option.getAttribute('data-price')) {
                            option.textContent = symbol;
                        }
                    }
                });
            } catch (err) {
                console.error('Error updating pair prices:', err);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            loadStatus();
            updateEvaluationUI();
            checkConnection();
            refreshPosition();
            refreshOrders();
            updatePairPrices(); // Load initial prices / Âä†ËΩΩÂàùÂßã‰ª∑Ê†º
            startAutoRefresh();
            
            // Initialize error history panel / ÂàùÂßãÂåñÈîôËØØÂéÜÂè≤Èù¢Êùø
            if (window.ErrorHistoryPanel) {
                new ErrorHistoryPanel('errorHistoryPanel', {
                    autoRefresh: true,
                    refreshInterval: 5000,
                    showTraceId: true
                });
            }
        });
    </script>
</body>

</html>




