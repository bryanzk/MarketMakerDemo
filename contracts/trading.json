{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "module": "trading",
  "version": "1.0.0",
  "description": "Trading engine interface contracts / 交易引擎接口契约",
  "owner": "Agent ARCH",
  "last_updated": "2025-12-01",
  "last_updated_by": "Agent ARCH",
  "readonly_for": ["Agent TRADING", "Agent PORTFOLIO", "Agent WEB", "Agent AI", "Agent QA"],
  "interfaces": {
    "ExchangeClient": {
      "description": "Base exchange client interface / 交易所客户端基础接口",
      "methods": {
        "__init__": {
          "description": "Initialize exchange client with API credentials",
          "params": {
            "api_key": "string (optional)",
            "api_secret": "string (optional)",
            "testnet": "boolean (optional)"
          },
          "returns": "void",
          "raises": []
        },
        "set_symbol": {
          "description": "Update the trading symbol",
          "params": {
            "symbol": "string"
          },
          "returns": "boolean",
          "raises": ["SymbolNotFoundError"]
        },
        "get_leverage": {
          "description": "Get current leverage for the symbol",
          "params": {},
          "returns": "integer",
          "raises": ["ConnectionError"]
        },
        "set_leverage": {
          "description": "Set leverage for the symbol",
          "params": {
            "leverage": "integer"
          },
          "returns": "boolean",
          "raises": ["ConnectionError", "InvalidLeverageError"]
        },
        "get_max_leverage": {
          "description": "Get maximum leverage for the symbol",
          "params": {},
          "returns": "integer",
          "raises": ["ConnectionError"]
        },
        "get_symbol_limits": {
          "description": "Get trading limits for the symbol",
          "params": {},
          "returns": {
            "minQty": "float",
            "maxQty": "float",
            "stepSize": "float",
            "minNotional": "float"
          },
          "raises": []
        },
        "fetch_market_data": {
          "description": "Fetch current market data (order book, mid price, tick/step sizes)",
          "params": {},
          "returns": {
            "best_bid": "float",
            "best_ask": "float",
            "mid_price": "float",
            "timestamp": "integer",
            "tick_size": "float",
            "step_size": "float"
          },
          "raises": ["ConnectionError", "SymbolNotFoundError"]
        },
        "fetch_funding_rate": {
          "description": "Fetch funding rate for current symbol",
          "params": {},
          "returns": "float",
          "raises": ["ConnectionError"]
        },
        "fetch_funding_rate_for_symbol": {
          "description": "Fetch funding rate for specific symbol",
          "params": {
            "symbol": "string"
          },
          "returns": "float",
          "raises": ["ConnectionError", "SymbolNotFoundError"]
        },
        "fetch_bulk_funding_rates": {
          "description": "Fetch funding rates for multiple symbols",
          "params": {
            "symbols": "array of string"
          },
          "returns": "dict[string, float]",
          "raises": ["ConnectionError"]
        },
        "fetch_ticker_stats": {
          "description": "Fetch 24h ticker statistics",
          "params": {},
          "returns": {
            "percentage": "float",
            "quoteVolume": "float"
          },
          "raises": ["ConnectionError"]
        },
        "fetch_account_data": {
          "description": "Fetch position and balance data (primary method for account information)",
          "params": {},
          "returns": {
            "position_amt": "float",
            "entry_price": "float",
            "balance": "float",
            "available_balance": "float",
            "liquidation_price": "float"
          },
          "raises": ["ConnectionError"],
          "notes": "This is the primary method for fetching account data. Position information can be extracted from position_amt, entry_price, and liquidation_price fields. Balance information is in balance and available_balance fields."
        },
        "fetch_open_orders": {
          "description": "Fetch all open orders for the symbol",
          "params": {},
          "returns": "array of Order objects",
          "raises": ["ConnectionError"]
        },
        "fetch_order": {
          "description": "Fetch order status by order ID",
          "params": {
            "order_id": "string"
          },
          "returns": {
            "order_id": "string",
            "symbol": "string",
            "side": "string (BUY|SELL)",
            "type": "string (LIMIT|MARKET)",
            "quantity": "float",
            "price": "float",
            "status": "string (open|filled|cancelled)",
            "filled_qty": "float",
            "timestamp": "integer"
          },
          "raises": ["ConnectionError", "OrderNotFoundError"]
        },
        "fetch_orders_history": {
          "description": "Fetch order history (filled, cancelled, or open orders)",
          "params": {
            "limit": "integer (optional, default: 100)",
            "start_time": "integer (optional, timestamp in milliseconds)"
          },
          "returns": "array of Order objects",
          "raises": ["ConnectionError"]
        },
        "place_orders": {
          "description": "Place a batch of orders",
          "params": {
            "orders": "array of OrderRequest"
          },
          "returns": "array of Order objects",
          "raises": ["InsufficientBalanceError", "InvalidOrderError", "NetworkError"]
        },
        "cancel_orders": {
          "description": "Cancel multiple orders by order IDs",
          "params": {
            "order_ids": "array of string"
          },
          "returns": "void",
          "raises": ["OrderNotFoundError", "NetworkError"]
        },
        "cancel_all_orders": {
          "description": "Cancel all open orders for the symbol",
          "params": {},
          "returns": "void",
          "raises": ["ConnectionError"]
        },
        "fetch_realized_pnl": {
          "description": "Fetch total realized PnL from transaction history",
          "params": {
            "start_time": "integer (optional, timestamp in milliseconds)"
          },
          "returns": "float",
          "raises": ["ConnectionError"]
        },
        "fetch_commission": {
          "description": "Fetch total trading commission/fees",
          "params": {
            "start_time": "integer (optional, timestamp in milliseconds)"
          },
          "returns": "float",
          "raises": ["ConnectionError"]
        },
        "fetch_pnl_and_fees": {
          "description": "Fetch both realized PnL and commission fees",
          "params": {
            "start_time": "integer (optional, timestamp in milliseconds)"
          },
          "returns": {
            "realized_pnl": "float",
            "commission": "float",
            "net_pnl": "float"
          },
          "raises": ["ConnectionError"]
        }
      }
    },
    "BinanceClient": {
      "description": "Binance Futures exchange client / 币安期货交易所客户端",
      "extends": "ExchangeClient",
      "implementation": "src/trading/exchange.py#BinanceClient"
    },
    "HyperliquidClient": {
      "description": "Hyperliquid exchange client / Hyperliquid 交易所客户端",
      "extends": "ExchangeClient",
      "implementation": "src/trading/hyperliquid_client.py#HyperliquidClient",
      "notes": "Must implement same interface as BinanceClient for seamless integration. Connection and authentication should be handled in __init__ method, consistent with BinanceClient pattern. All order management methods (place_orders, cancel_orders, fetch_order, fetch_orders_history, etc.) must be implemented to support US-CORE-004-B requirements. / 必须实现与 BinanceClient 相同的接口以实现无缝集成。连接和认证应在 __init__ 方法中处理，与 BinanceClient 模式保持一致。所有订单管理方法（place_orders, cancel_orders, fetch_order, fetch_orders_history 等）必须实现以支持 US-CORE-004-B 需求。",
      "methods": {
        "__init__": {
          "description": "Initialize Hyperliquid client with API credentials and environment. Establishes connection and authenticates during initialization, consistent with BinanceClient pattern.",
          "params": {
            "api_key": "string (optional, from HYPERLIQUID_API_KEY env var)",
            "api_secret": "string (optional, from HYPERLIQUID_API_SECRET env var)",
            "testnet": "boolean (optional, from HYPERLIQUID_TESTNET env var)"
          },
          "returns": "void",
          "raises": ["ConnectionError", "AuthenticationError"],
          "notes": "Connects to testnet.hyperliquid.xyz if testnet=true, else api.hyperliquid.xyz. Connection and authentication are performed during initialization, not in a separate connect() method, to maintain interface consistency with BinanceClient."
        }
      },
      "order_methods_requirements": {
        "description": "Order management methods required for US-CORE-004-B / US-CORE-004-B 所需的订单管理方法",
        "required_methods": [
          "place_orders(orders) - Place batch of limit/market orders",
          "cancel_orders(order_ids) - Cancel multiple orders",
          "cancel_all_orders() - Cancel all open orders",
          "fetch_order(order_id) - Get order status by ID",
          "fetch_open_orders() - Get all open orders",
          "fetch_orders_history(limit, start_time) - Get order history"
        ],
        "error_handling": "Must map Hyperliquid-specific errors to standard exceptions (InsufficientFunds, InvalidOrder, OrderNotFound) with bilingual error messages / 必须将 Hyperliquid 特定错误映射到标准异常（余额不足、无效订单、订单未找到），并提供双语错误消息",
        "order_format": "Must convert between Hyperliquid API format and internal Order format for consistency with Binance / 必须在 Hyperliquid API 格式和内部 Order 格式之间转换，以与 Binance 保持一致"
      }
    },
    "OrderManager": {
      "description": "Order placement and management / 订单管理",
      "methods": {
        "place_order": {
          "description": "Place a new order",
          "params": {
            "symbol": "string",
            "side": "string (BUY|SELL)",
            "order_type": "string (LIMIT|MARKET)",
            "quantity": "float",
            "price": "float (optional for MARKET)"
          },
          "returns": {
            "order_id": "string",
            "status": "string",
            "filled_qty": "float"
          },
          "raises": ["InsufficientBalanceError", "InvalidOrderError"]
        },
        "cancel_order": {
          "description": "Cancel an existing order",
          "params": {
            "order_id": "string"
          },
          "returns": "boolean",
          "raises": ["OrderNotFoundError"]
        },
        "get_open_orders": {
          "description": "Get all open orders",
          "params": {
            "symbol": "string (optional)"
          },
          "returns": "array of Order objects",
          "raises": ["ConnectionError"]
        }
      }
    },
    "Strategy": {
      "description": "Base strategy interface / 策略基础接口",
      "methods": {
        "initialize": {
          "description": "Initialize strategy with config",
          "params": {
            "config": "StrategyConfig"
          },
          "returns": "void",
          "raises": ["InvalidConfigError"]
        },
        "on_tick": {
          "description": "Called on each market data update",
          "params": {
            "market_data": "MarketData"
          },
          "returns": {
            "orders": "array of OrderRequest"
          },
          "raises": []
        },
        "get_status": {
          "description": "Get current strategy status",
          "params": {},
          "returns": {
            "name": "string",
            "running": "boolean",
            "pnl": "float",
            "position": "float"
          },
          "raises": []
        }
      }
    },
    "FixedSpreadStrategy": {
      "extends": "Strategy",
      "description": "Fixed spread market-making strategy / 固定价差做市策略",
      "config": {
        "spread": "float (0.001 - 0.05)",
        "quantity": "float",
        "max_position": "float",
        "skew_factor": "float (50 - 200)"
      }
    },
    "FundingRateStrategy": {
      "extends": "Strategy",
      "description": "Funding rate arbitrage strategy / 资金费率套利策略",
      "config": {
        "threshold": "float",
        "quantity": "float",
        "max_position": "float"
      }
    }
  },
  "data_types": {
    "MarketData": {
      "symbol": "string",
      "mid_price": "float",
      "best_bid": "float",
      "best_ask": "float",
      "timestamp": "datetime"
    },
    "Order": {
      "order_id": "string",
      "symbol": "string",
      "side": "string",
      "type": "string",
      "quantity": "float",
      "price": "float",
      "status": "string",
      "created_at": "datetime"
    },
    "OrderRequest": {
      "side": "string",
      "type": "string",
      "quantity": "float",
      "price": "float"
    },
    "StrategyConfig": {
      "name": "string",
      "symbol": "string",
      "params": "object"
    }
  }
}


