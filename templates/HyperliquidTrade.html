<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Hyperliquid Trading Page / Hyperliquid äº¤æ˜“é¡µé¢</title>
    <style>
        body {
            margin: 0;
            font-family: "Inter", "PingFang SC", sans-serif;
            background: #f5f5fa;
            color: #1f2937;
        }

        a {
            color: #3b82f6;
            text-decoration: none;
        }

        .page {
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }

        .panel {
            background: #ffffff;
            border-radius: 14px;
            box-shadow: 0 8px 30px rgba(15, 23, 42, 0.08);
            padding: 24px;
            margin-bottom: 24px;
        }

        .panel h2 {
            margin: 0 0 16px;
            font-size: 20px;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 16px;
        }

        label {
            font-size: 13px;
            color: #6b7280;
            display: block;
            margin-bottom: 6px;
        }

        input,
        select {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
            background: #f9fafb;
            font-size: 14px;
            box-sizing: border-box;
        }

        .btn {
            border: none;
            border-radius: 8px;
            padding: 10px 16px;
            font-size: 14px;
            cursor: pointer;
        }

        .btn-primary {
            background: #4f46e5;
            color: #fff;
        }

        .btn-secondary {
            background: #e5e7eb;
            color: #374151;
        }

        .btn-success {
            background: #22c55e;
            color: #fff;
        }

        .btn-danger {
            background: #ef4444;
            color: #fff;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        table th,
        table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #f3f4f6;
        }

        .message {
            margin-top: 12px;
            font-size: 13px;
        }

        .message.error {
            color: #b91c1c;
        }

        .message.success {
            color: #059669;
        }

        .consensus-card {
            border: 1px dashed #c4b5fd;
            padding: 12px;
            border-radius: 10px;
            background: #f5f3ff;
            margin-top: 16px;
        }

        .nav-link {
            font-size: 14px;
            padding: 8px 14px;
            border-radius: 999px;
            background: #eef2ff;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .status-connected {
            background: #d1fae5;
            color: #065f46;
        }

        .status-disconnected {
            background: #fee2e2;
            color: #991b1b;
        }

        .network-badge {
            display: inline-block;
            padding: 6px 14px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            border: 2px solid;
        }

        .network-mainnet {
            background: #f0fdf4;
            color: #166534;
            border-color: #22c55e;
        }

        .network-testnet {
            background: #fef3c7;
            color: #92400e;
            border-color: #f59e0b;
        }

        .info-card {
            background: #f0f9ff;
            border: 1px solid #bae6fd;
            padding: 12px;
            border-radius: 8px;
            margin-top: 12px;
        }

        .provider-status-item {
            padding: 12px;
            border-radius: 8px;
            border: 2px solid #e5e7eb;
            background: #ffffff;
            transition: all 0.3s;
        }

        .provider-status-item.active {
            border-color: #3b82f6;
            background: #eff6ff;
        }

        .provider-status-item.completed {
            border-color: #22c55e;
            background: #f0fdf4;
        }

        .provider-status-item.failed {
            border-color: #ef4444;
            background: #fef2f2;
        }

        .step-indicator {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            background: #e5e7eb;
            color: #374151;
        }

        .step-indicator.active {
            background: #3b82f6;
            color: #ffffff;
        }

        .step-indicator.completed {
            background: #22c55e;
            color: #ffffff;
        }

        .step-indicator.failed {
            background: #ef4444;
            color: #ffffff;
        }

        .individual-progress-bar {
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 4px;
        }

        .individual-progress-bar-fill {
            height: 100%;
            background: #3b82f6;
            transition: width 0.3s;
        }
    </style>
    <!-- Error handling styles / é”™è¯¯å¤„ç†æ ·å¼ -->
    <link rel="stylesheet" href="/static/error_styles.css">
    <link rel="stylesheet" href="/static/debug_panel.css">
    <link rel="stylesheet" href="/static/validation.css">
    <link rel="stylesheet" href="/static/error_history.css">
    <!-- API Diagnostics and Error Handler / API è¯Šæ–­å’Œé”™è¯¯å¤„ç† -->
    <script src="/static/api_diagnostics.js"></script>
    <script src="/static/error_handler.js"></script>
    <script src="/static/debug_panel.js"></script>
    <script src="/static/validation.js"></script>
    <script src="/static/error_history.js"></script>
</head>

<body>
    <div class="page">
        <header>
            <div>
                <h1 style="margin:0;">Hyperliquid Trading Page / Hyperliquid äº¤æ˜“é¡µé¢</h1>
                <div style="font-size:13px; color:#6b7280;">Dedicated interface for Hyperliquid exchange trading / ä¸“ç”¨ Hyperliquid äº¤æ˜“æ‰€äº¤æ˜“ç•Œé¢</div>
            </div>
            <div style="display:flex; gap:12px; align-items:center;">
                <span id="networkStatus" class="network-badge" style="display:none;">
                    <span id="networkText">Mainnet / ä¸»ç½‘</span>
                </span>
                <span id="connectionStatus" class="status-badge status-disconnected">Checking...</span>
                <a class="nav-link" href="/">â† Back to Dashboard</a>
            </div>
        </header>

        <!-- Connection Status Panel / è¿æ¥çŠ¶æ€é¢æ¿ -->
        <section class="panel">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <h2 style="margin:0;">Connection Status / è¿æ¥çŠ¶æ€</h2>
                <div style="display:flex; gap:8px;">
                    <a href="https://hyperliquid-testnet.xyz" target="_blank" class="btn btn-secondary" style="font-size:12px; padding:6px 12px;">
                        ğŸ”— Testnet Website / æµ‹è¯•ç½‘ç½‘ç«™
                    </a>
                    <a href="https://hyperliquid.xyz" target="_blank" class="btn btn-secondary" style="font-size:12px; padding:6px 12px;">
                        ğŸ”— Mainnet Website / ä¸»ç½‘ç½‘ç«™
                    </a>
                </div>
            </div>
            <div id="connectionInfo" class="info-card" style="margin-top:16px;">
                <div>Exchange: <strong>Hyperliquid</strong></div>
                <div id="connectionDetails" style="margin-top:8px; font-size:13px; color:#6b7280;">Loading connection status...</div>
                <div id="testnetConnectionHint" style="margin-top:12px; padding:12px; background:#fef3c7; border-radius:8px; border-left:3px solid #f59e0b; display:none;">
                    <div style="font-size:12px; font-weight:600; margin-bottom:6px; color:#92400e;">
                        ğŸ”— Connect to Testnet / è¿æ¥åˆ°æµ‹è¯•ç½‘
                    </div>
                    <div style="font-size:11px; color:#78350f; line-height:1.6; margin-bottom:8px;">
                        To connect to Hyperliquid Testnet, set the environment variable and restart the server:
                        è¦è¿æ¥åˆ° Hyperliquid æµ‹è¯•ç½‘ï¼Œè¯·è®¾ç½®ç¯å¢ƒå˜é‡å¹¶é‡å¯æœåŠ¡å™¨ï¼š
                    </div>
                    <div style="background:#1f2937; color:#f9fafb; padding:8px; border-radius:6px; font-family:monospace; font-size:11px; margin-bottom:8px;">
                        export HYPERLIQUID_TESTNET="true"<br>
                        export HYPERLIQUID_API_KEY="your_testnet_key"<br>
                        export HYPERLIQUID_API_SECRET="your_testnet_secret"
                    </div>
                    <div style="display:flex; gap:8px; flex-wrap:wrap;">
                        <a href="https://hyperliquid-testnet.xyz" target="_blank" style="font-size:11px; color:#3b82f6; text-decoration:underline;">
                            ğŸ“– Testnet Documentation / æµ‹è¯•ç½‘æ–‡æ¡£
                        </a>
                        <a href="https://hyperliquid.xyz" target="_blank" style="font-size:11px; color:#3b82f6; text-decoration:underline;">
                            ğŸ“– Mainnet Documentation / ä¸»ç½‘æ–‡æ¡£
                        </a>
                    </div>
                </div>
            </div>
        </section>

        <!-- Position and Balance Panel / ä»“ä½ä¸ä½™é¢é¢æ¿ -->
        <section class="panel">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <h2 style="margin:0;">Position & Balance / ä»“ä½ä¸ä½™é¢</h2>
                <button class="btn btn-secondary" onclick="refreshPosition()">ğŸ”„ Refresh</button>
            </div>
            <div id="positionStatus" class="message" style="color:#6b7280; margin-top:12px;">Loading position data...</div>
            <div id="positionData" style="display:none; margin-top:16px;">
                <div class="grid">
                    <div>
                        <label>Total Balance / æ€»ä½™é¢</label>
                        <div style="font-size:20px; font-weight:bold;" id="totalBalance">--</div>
                    </div>
                    <div>
                        <label>Available Balance / å¯ç”¨ä½™é¢</label>
                        <div style="font-size:20px; font-weight:bold;" id="availableBalance">--</div>
                    </div>
                    <div>
                        <label>Position Amount / ä»“ä½æ•°é‡</label>
                        <div style="font-size:20px; font-weight:bold;" id="positionAmount">--</div>
                    </div>
                    <div>
                        <label>Unrealized PnL / æœªå®ç°ç›ˆäº</label>
                        <div style="font-size:20px; font-weight:bold;" id="unrealizedPnL">--</div>
                    </div>
                </div>
                <div style="margin-top:16px;">
                    <h3 style="font-size:14px; margin-bottom:8px;">Open Positions / æœªå¹³ä»“</h3>
                    <div id="positionsTable" style="overflow-x:auto;">
                        <table>
                            <thead>
                                <tr style="background:#f3f4f6;">
                                    <th>Symbol / äº¤æ˜“å¯¹</th>
                                    <th>Side / æ–¹å‘</th>
                                    <th>Size / æ•°é‡</th>
                                    <th>Entry Price / å…¥åœºä»·</th>
                                    <th>Mark Price / æ ‡è®°ä»·</th>
                                    <th>PnL / ç›ˆäº</th>
                                </tr>
                            </thead>
                            <tbody id="positionsTableBody">
                                <tr><td colspan="6" style="text-align:center; color:#6b7280;">No open positions / æ— æœªå¹³ä»“</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </section>

        <!-- Strategy Control Panel / ç­–ç•¥æ§åˆ¶é¢æ¿ -->
        <section class="panel">
            <h2>Fixed Spread Strategy Control Panel / å›ºå®šä»·å·®ç­–ç•¥æ§åˆ¶é¢æ¿</h2>
            <div class="grid">
                <div>
                    <label>Trading Pair / äº¤æ˜“å¯¹</label>
                    <select id="pairSelect" onchange="switchPair()">
                        <option value="ETH/USDC:USDC">ETH/USDC:USDC (--)</option>
                        <option value="BTC/USDC:USDC">BTC/USDC:USDC (--)</option>
                        <option value="SOL/USDC:USDC">SOL/USDC:USDC (--)</option>
                    </select>
                </div>
            </div>
            <div class="grid" style="margin-top: 16px;">
                <div>
                    <label>Spread (%) / ä»·å·® (%)</label>
                    <input type="number" id="spreadInput" step="0.01" value="1.5">
                </div>
                <div>
                    <label>Quantity / æ•°é‡</label>
                    <input type="number" id="quantityInput" step="0.01" value="0.1">
                </div>
                <div>
                    <label>Leverage / æ æ†</label>
                    <input type="number" id="leverageInput" min="1" max="125" value="5">
                </div>
            </div>
            <div style="margin-top: 8px; font-size: 12px; color: #6b7280;">
                Note: Fixed Spread Strategy does not use Skew Factor / æ³¨æ„ï¼šå›ºå®šä»·å·®ç­–ç•¥ä¸ä½¿ç”¨å€¾æ–œå› å­
            </div>
            <div style="display:flex; gap:12px; margin-top:16px;">
                <button class="btn btn-primary" onclick="updateConfig()">ğŸ’¾ Save Strategy Config</button>
                <button class="btn btn-secondary" onclick="updateLeverage()">âš¡ Update Leverage</button>
            </div>
            <div id="controlMessage" class="message"></div>
        </section>

        <!-- LLM Evaluation Panel / LLM è¯„ä¼°é¢æ¿ -->
        <section class="panel">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <div>
                    <h2 style="margin:0;">Multi-LLM Evaluation / å¤šæ¨¡å‹è¯„ä¼°</h2>
                    <div style="font-size:13px; color:#6b7280;">Gemini Â· OpenAI Â· Claude (Hyperliquid Context)</div>
                </div>
                <button id="runEvaluationBtn" class="btn btn-primary" onclick="runEvaluation()">ğŸš€ Run Evaluation</button>
            </div>
            <div id="evaluationStatusText" class="message" style="color:#6b7280; margin-top:12px;">Ready.</div>
            <div id="evaluationErrorBox" class="message error" style="display:none;"></div>

            <!-- Evaluation Progress Display / è¯„ä¼°è¿›åº¦æ˜¾ç¤º (AC-11) -->
            <div id="evaluationProgressPanel" style="display:none; margin-top:16px; padding:16px; background:#f9fafb; border-radius:8px; border:1px solid #e5e7eb;">
                <!-- Overall Status / æ€»ä½“çŠ¶æ€ -->
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
                    <div>
                        <div style="font-weight:bold; font-size:14px;" id="overallStatusText">Evaluation in Progress / è¯„ä¼°è¿›è¡Œä¸­</div>
                        <div style="font-size:12px; color:#6b7280; margin-top:4px;" id="elapsedTimeText">Elapsed: 0m 0s / å·²ç”¨æ—¶é—´: 0åˆ† 0ç§’</div>
                    </div>
                    <div id="overallStatusIcon" style="font-size:20px;">â³</div>
                </div>
                
                <!-- Overall Progress Bar / æ€»ä½“è¿›åº¦æ¡ -->
                <div style="margin-bottom:16px;">
                    <div style="display:flex; justify-content:space-between; margin-bottom:4px;">
                        <span style="font-size:12px; color:#6b7280;" id="overallProgressText">0 / 0 providers completed / 0 / 0 ä¸ªæä¾›å•†å·²å®Œæˆ</span>
                        <span style="font-size:12px; color:#6b7280;" id="overallProgressPercent">0%</span>
                    </div>
                    <div style="height:8px; background:#e5e7eb; border-radius:4px; overflow:hidden;">
                        <div id="overallProgressBar" style="height:100%; background:#3b82f6; width:0%; transition:width 0.3s;"></div>
                    </div>
                </div>

                <!-- Provider Status List / æä¾›å•†çŠ¶æ€åˆ—è¡¨ -->
                <div id="providerStatusList" style="display:flex; flex-direction:column; gap:12px;">
                    <!-- Provider status items will be dynamically inserted here -->
                </div>
            </div>

            <div id="evaluationConsensusCard" class="consensus-card" style="display:none;">
                <div style="font-size:14px; font-weight:bold; color:#6d28d9;">ğŸ¤ Consensus Recommendation / å…±è¯†å»ºè®®</div>
                <div style="margin-top:8px; font-size:13px;">
                    <div>Strategy: <span id="evaluationConsensusStrategy" style="font-weight:bold;">--</span></div>
                    <div>Spread / Qty / Lev:
                        <span id="evaluationConsensusParams" style="font-weight:bold;">--</span>
                    </div>
                </div>
                <div id="evaluationConsensusStats" style="margin-top:6px; font-size:12px; color:#4b5563;">--</div>
                <div id="evaluationConsensusReasoning" style="margin-top:8px; font-size:12px; color:#6b7280;">--</div>
                <div style="display:flex; gap:8px; margin-top:12px;">
                    <button class="btn btn-success" style="flex:1;"
                        onclick="applyEvaluation('consensus')">Apply Consensus</button>
                    <button class="btn btn-primary" style="flex:1;"
                        onclick="startBotWithLLMSuggestion()">ğŸš€ Start Bot</button>
                </div>
            </div>

            <div id="evaluationResultsWrapper" style="margin-top:20px; display:none;">
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <div style="font-size:13px; font-weight:bold;">Model Comparison / æ¨¡å‹å¯¹æ¯”</div>
                    <div id="evaluationLastRun" style="font-size:11px; color:#6b7280;"></div>
                </div>
                <div style="overflow-x:auto; margin-top:8px;">
                    <table>
                        <thead>
                            <tr style="background:#f3f4f6;">
                                <th>Rank</th>
                                <th>Provider</th>
                                <th>Strategy</th>
                                <th>Spread</th>
                                <th>Qty</th>
                                <th>Lev</th>
                                <th>Confidence</th>
                                <th>PnL</th>
                                <th>Sharpe</th>
                                <th>Win%</th>
                                <th>Score</th>
                                <th></th>
                            </tr>
                        </thead>
                        <tbody id="evaluationResultsBody"></tbody>
                    </table>
                </div>
            </div>
        </section>

        <!-- Orders Panel / è®¢å•é¢æ¿ -->
        <section class="panel">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <div>
                    <h2 style="margin:0;">Current Orders / å½“å‰è®¢å•</h2>
                    <div style="font-size:13px; color:#6b7280;">Real-time order status</div>
                </div>
                <button class="btn btn-secondary" onclick="refreshOrders()">ğŸ”„ Refresh</button>
            </div>
            <div id="ordersStatusText" class="message" style="color:#6b7280; margin-top:12px;">Loading orders...</div>
            <div id="ordersTableWrapper" style="margin-top:16px; display:none;">
                <div style="overflow-x:auto;">
                    <table>
                        <thead>
                            <tr style="background:#f3f4f6;">
                                <th>Order ID</th>
                                <th>Side</th>
                                <th>Price</th>
                                <th>Quantity</th>
                                <th>Status</th>
                                <th>Time</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody id="ordersTableBody"></tbody>
                    </table>
                </div>
                <div id="ordersEmptyMessage" style="text-align:center; padding:24px; color:#6b7280; display:none;">
                    No active orders / æ— æ´»è·ƒè®¢å•
                </div>
            </div>
        </section>

        <!-- Error History Panel / é”™è¯¯å†å²é¢æ¿ -->
        <section class="panel">
            <div id="errorHistoryPanel"></div>
        </section>
    </div>

    <script>
        const controlMessage = document.getElementById('controlMessage');
        let currentEvalSymbol = 'ETHUSDC';
        let evaluationState = {
            loading: false,
            results: [],
            aggregated: null,
            lastError: null,
            lastRunSymbol: null,
            lastRunAt: null,
            startTime: null,
            elapsedInterval: null,
            providers: ['Gemini', 'OpenAI', 'Claude'], // Expected providers
            providerStatus: {}, // Track status for each provider
        };

        function showMessage(el, text, isError = false) {
            if (!el) return;
            el.innerText = text;
            el.classList.toggle('error', isError);
            el.classList.toggle('success', !isError);
        }

        function normalizeSymbol(symbol) {
            if (!symbol) return 'ETHUSDC';
            return symbol.toUpperCase().replace(/[:\/-]/g, '');
        }

        // Connection Status / è¿æ¥çŠ¶æ€
        let lastConnectionCheckTime = 0;
        const CONNECTION_CHECK_INTERVAL = 15000; // Check connection every 15 seconds / æ¯ 15 ç§’æ£€æŸ¥ä¸€æ¬¡è¿æ¥
        
        async function checkConnection() {
            // Prevent duplicate requests / é˜²æ­¢é‡å¤è¯·æ±‚
            if (isCheckingConnection) return;
            
            // Throttle connection checks to avoid excessive API calls / é™åˆ¶è¿æ¥æ£€æŸ¥ä»¥é¿å…è¿‡å¤š API è°ƒç”¨
            const now = Date.now();
            if (now - lastConnectionCheckTime < CONNECTION_CHECK_INTERVAL) {
                return;
            }
            
            isCheckingConnection = true;
            lastConnectionCheckTime = now;
            
            try {
                // Get currently selected pair / è·å–å½“å‰é€‰ä¸­çš„äº¤æ˜“å¯¹
                const pairSelect = document.getElementById('pairSelect');
                const selectedSymbol = pairSelect ? pairSelect.value : null;
                
                // Use Hyperliquid status API to check connection (faster than evaluation API)
                // ä½¿ç”¨ Hyperliquid çŠ¶æ€ API æ£€æŸ¥è¿æ¥ï¼ˆæ¯”è¯„ä¼° API æ›´å¿«ï¼‰
                // If a specific symbol is selected, we'll update the status with that symbol's price
                // å¦‚æœé€‰æ‹©äº†ç‰¹å®šäº¤æ˜“å¯¹ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨è¯¥äº¤æ˜“å¯¹çš„ä»·æ ¼æ›´æ–°çŠ¶æ€
                const res = await diagnosticFetch('/api/hyperliquid/status');
                const data = await res.json();
                
                const statusEl = document.getElementById('connectionStatus');
                const detailsEl = document.getElementById('connectionDetails');
                const networkEl = document.getElementById('networkStatus');
                const networkTextEl = document.getElementById('networkText');
                
                if (!statusEl || !detailsEl) {
                    return; // Elements not found, page might not be fully loaded
                }
                
                // Handle rate limit error / å¤„ç†é€Ÿç‡é™åˆ¶é”™è¯¯
                if (data.error && (data.error.includes('429') || data.error.includes('Too Many Requests') || data.error.includes('é€Ÿç‡é™åˆ¶'))) {
                    statusEl.className = 'status-badge status-disconnected';
                    statusEl.innerText = 'Rate Limited / é€Ÿç‡é™åˆ¶';
                    detailsEl.innerHTML = '<span style="color:#f59e0b;">Too many requests. Please wait... / è¯·æ±‚è¿‡å¤šï¼Œè¯·ç¨å€™...</span>';
                    // Extend refresh interval on rate limit / é€Ÿç‡é™åˆ¶æ—¶å»¶é•¿åˆ·æ–°é—´éš”
                    if (connectionRefreshInterval) {
                        clearInterval(connectionRefreshInterval);
                        connectionRefreshInterval = setInterval(checkConnection, 60000); // 1 minute
                    }
                    return;
                }
                
                // Update network status (testnet/mainnet)
                // æ›´æ–°ç½‘ç»œçŠ¶æ€ï¼ˆæµ‹è¯•ç½‘/ä¸»ç½‘ï¼‰
                const isTestnet = data.testnet === true;
                const testnetHintEl = document.getElementById('testnetConnectionHint');
                
                if (networkEl && networkTextEl) {
                    networkEl.style.display = 'inline-block';
                    if (isTestnet) {
                        networkEl.className = 'network-badge network-testnet';
                        networkTextEl.innerText = 'âš ï¸ TESTNET / æµ‹è¯•ç½‘';
                    } else {
                        networkEl.className = 'network-badge network-mainnet';
                        networkTextEl.innerText = 'âœ“ MAINNET / ä¸»ç½‘';
                    }
                }
                
                // Show/hide testnet connection hint based on connection status
                // æ ¹æ®è¿æ¥çŠ¶æ€æ˜¾ç¤º/éšè—æµ‹è¯•ç½‘è¿æ¥æç¤º
                if (testnetHintEl) {
                    // Only show hint if not connected or if connected to mainnet (to suggest switching to testnet)
                    // ä»…åœ¨æœªè¿æ¥æˆ–è¿æ¥åˆ°ä¸»ç½‘æ—¶æ˜¾ç¤ºæç¤ºï¼ˆå»ºè®®åˆ‡æ¢åˆ°æµ‹è¯•ç½‘ï¼‰
                    if (!data.connected || !isTestnet) {
                        testnetHintEl.style.display = 'block';
                    } else {
                        // Already connected to testnet, hide the hint
                        // å·²è¿æ¥åˆ°æµ‹è¯•ç½‘ï¼Œéšè—æç¤º
                        testnetHintEl.style.display = 'none';
                    }
                }
                
                if (data.error || !data.connected) {
                    // Not connected
                    statusEl.className = 'status-badge status-disconnected';
                    statusEl.innerText = 'Disconnected / æœªè¿æ¥';
                    const errorMsg = data.error || 'Hyperliquid exchange not connected / Hyperliquid äº¤æ˜“æ‰€æœªè¿æ¥';
                    detailsEl.innerHTML = `<span style="color:#991b1b;">${errorMsg}</span>`;
                } else {
                    // Connected - show price for currently selected pair / å·²è¿æ¥ - æ˜¾ç¤ºå½“å‰é€‰ä¸­äº¤æ˜“å¯¹çš„ä»·æ ¼
                    statusEl.className = 'status-badge status-connected';
                    statusEl.innerText = 'Connected / å·²è¿æ¥';
                    
                    // Get currently selected symbol / è·å–å½“å‰é€‰ä¸­çš„äº¤æ˜“å¯¹
                    const pairSelect = document.getElementById('pairSelect');
                    const selectedSymbol = pairSelect ? pairSelect.value : null;
                    
                    // Use selected symbol price if available, otherwise use status API price / å¦‚æœå¯ç”¨åˆ™ä½¿ç”¨é€‰ä¸­äº¤æ˜“å¯¹ä»·æ ¼ï¼Œå¦åˆ™ä½¿ç”¨çŠ¶æ€ API ä»·æ ¼
                    let displaySymbol = selectedSymbol || data.symbol || 'N/A';
                    let displayPrice = null;
                    
                    // Try to get price from cache first / å…ˆå°è¯•ä»ç¼“å­˜è·å–ä»·æ ¼
                    if (selectedSymbol && pairPrices[selectedSymbol] !== null && pairPrices[selectedSymbol] !== undefined) {
                        displayPrice = pairPrices[selectedSymbol];
                    } else if (data.mid_price && data.mid_price > 0) {
                        // Fallback to status API price / å›é€€åˆ°çŠ¶æ€ API ä»·æ ¼
                        displayPrice = data.mid_price;
                    } else if (selectedSymbol) {
                        // Try to fetch price for selected symbol / å°è¯•è·å–é€‰ä¸­äº¤æ˜“å¯¹çš„ä»·æ ¼
                        displayPrice = await getPairPrice(selectedSymbol);
                    }
                    
                    // Convert USDT to USDC for Hyperliquid display / å°† USDT è½¬æ¢ä¸º USDC ç”¨äº Hyperliquid æ˜¾ç¤º
                    if (displaySymbol.includes('USDT')) {
                        displaySymbol = displaySymbol.replace(/USDT/g, 'USDC');
                    }
                    
                    const balance = data.balance || 0;
                    const priceText = displayPrice !== null && displayPrice > 0 
                        ? `$${displayPrice.toFixed(2)}` 
                        : '--';
                    
                    detailsEl.innerHTML = `
                        <div>Symbol: <strong>${displaySymbol}</strong> | Price: <strong>${priceText}</strong></div>
                        <div style="margin-top:4px;">Balance: <strong>${balance.toFixed(2)} USDC</strong></div>
                    `;
                }
                
                // Reset refresh interval on success / æˆåŠŸæ—¶é‡ç½®åˆ·æ–°é—´éš”
                if (connectionRefreshInterval) {
                    clearInterval(connectionRefreshInterval);
                    connectionRefreshInterval = setInterval(checkConnection, 30000); // 30 seconds
                }
            } catch (err) {
                const statusEl = document.getElementById('connectionStatus');
                const detailsEl = document.getElementById('connectionDetails');
                if (statusEl && detailsEl) {
                    statusEl.className = 'status-badge status-disconnected';
                    statusEl.innerText = 'Error / é”™è¯¯';
                    detailsEl.innerHTML = `<span style="color:#991b1b;">Failed to check connection: ${err.message} / æ£€æŸ¥è¿æ¥å¤±è´¥ï¼š${err.message}</span>`;
                }
            } finally {
                isCheckingConnection = false;
            }
        }

        // Track if refresh is in progress to avoid duplicate requests
        // è·Ÿè¸ªåˆ·æ–°æ˜¯å¦æ­£åœ¨è¿›è¡Œï¼Œé¿å…é‡å¤è¯·æ±‚
        let isRefreshingPosition = false;
        let isRefreshingOrders = false;
        let isCheckingConnection = false;

        // Position and Balance / ä»“ä½ä¸ä½™é¢
        async function refreshPosition() {
            // Prevent duplicate requests / é˜²æ­¢é‡å¤è¯·æ±‚
            if (isRefreshingPosition) return;
            isRefreshingPosition = true;
            
            try {
                const statusEl = document.getElementById('positionStatus');
                if (statusEl) {
                    statusEl.innerText = 'Loading position data... / æ­£åœ¨åŠ è½½ä»“ä½æ•°æ®...';
                    statusEl.classList.remove('error');
                }
                
                // Get Hyperliquid-specific status / è·å– Hyperliquid ç‰¹å®šçŠ¶æ€
                const res = await diagnosticFetch('/api/hyperliquid/status');
                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                }
                const data = await res.json();
                
                if (data.error) {
                    const positionData = document.getElementById('positionData');
                    if (positionData) positionData.style.display = 'none';
                    
                    // Check for rate limit error / æ£€æŸ¥é€Ÿç‡é™åˆ¶é”™è¯¯
                    if (data.error.includes('429') || data.error.includes('Too Many Requests') || data.error.includes('é€Ÿç‡é™åˆ¶')) {
                        if (statusEl) {
                            statusEl.innerText = 'Rate limit exceeded. Please wait... / é€Ÿç‡é™åˆ¶å·²è¶…å‡ºï¼Œè¯·ç¨å€™...';
                            statusEl.classList.add('error');
                        }
                        // Extend refresh interval on rate limit / é€Ÿç‡é™åˆ¶æ—¶å»¶é•¿åˆ·æ–°é—´éš”
                        if (positionRefreshInterval) {
                            clearInterval(positionRefreshInterval);
                            positionRefreshInterval = setInterval(refreshPosition, 60000); // 1 minute
                        }
                    } else {
                        if (statusEl) {
                            statusEl.innerText = data.error;
                            statusEl.classList.add('error');
                        }
                    }
                    return;
                }
                
                const positionData = document.getElementById('positionData');
                const totalBalanceEl = document.getElementById('totalBalance');
                const availableBalanceEl = document.getElementById('availableBalance');
                const positionAmountEl = document.getElementById('positionAmount');
                const unrealizedPnLEl = document.getElementById('unrealizedPnL');
                const positionsTableBody = document.getElementById('positionsTableBody');
                
                // Always show data if connected, even if balance is 0
                // å¦‚æœå·²è¿æ¥ï¼Œå³ä½¿ä½™é¢ä¸º 0 ä¹Ÿæ˜¾ç¤ºæ•°æ®
                if (data.connected && data.balance !== undefined) {
                    if (positionData) positionData.style.display = 'block';
                    if (totalBalanceEl) totalBalanceEl.innerText = `$${(data.balance || 0).toFixed(2)}`;
                    if (availableBalanceEl) availableBalanceEl.innerText = `$${(data.available_balance || 0).toFixed(2)}`;
                    if (positionAmountEl) positionAmountEl.innerText = `${(data.position || 0).toFixed(4)}`;
                    if (unrealizedPnLEl) unrealizedPnLEl.innerText = `$${((data.unrealized_pnl || 0)).toFixed(2)}`;
                    if (statusEl) {
                        statusEl.innerText = 'Position data loaded / ä»“ä½æ•°æ®å·²åŠ è½½';
                        statusEl.classList.remove('error');
                    }
                    
                    // Populate positions table / å¡«å……ä»“ä½è¡¨æ ¼
                    if (positionsTableBody) {
                        if (data.positions && Array.isArray(data.positions) && data.positions.length > 0) {
                            const rows = data.positions.map(pos => {
                                const symbol = pos.symbol || pos.coin || '--';
                                const side = pos.side || (pos.szi > 0 ? 'LONG' : 'SHORT') || '--';
                                const size = Math.abs(pos.szi || pos.size || 0);
                                const entryPrice = pos.entryPx || pos.entry_price || 0;
                                const markPrice = pos.markPx || pos.mark_price || data.mid_price || 0;
                                const pnl = pos.unrealizedPnl || pos.unrealized_pnl || 0;
                                
                                return `
                                    <tr>
                                        <td>${symbol}</td>
                                        <td><span style="color:${side === 'LONG' || side === 'BUY' ? '#22c55e' : '#ef4444'}; font-weight:bold;">${side}</span></td>
                                        <td>${size.toFixed(4)}</td>
                                        <td>$${entryPrice.toFixed(2)}</td>
                                        <td>$${markPrice.toFixed(2)}</td>
                                        <td style="color:${pnl >= 0 ? '#22c55e' : '#ef4444'};">$${pnl.toFixed(2)}</td>
                                    </tr>
                                `;
                            }).join('');
                            positionsTableBody.innerHTML = rows;
                        } else {
                            positionsTableBody.innerHTML = '<tr><td colspan="6" style="text-align:center; color:#6b7280;">No open positions / æ— æœªå¹³ä»“</td></tr>';
                        }
                    }
                } else {
                    if (positionData) positionData.style.display = 'none';
                    if (statusEl) {
                        statusEl.innerText = 'Position data not available / ä»“ä½æ•°æ®ä¸å¯ç”¨';
                        statusEl.classList.add('error');
                    }
                }
            } catch (err) {
                const statusEl = document.getElementById('positionStatus');
                if (statusEl) {
                    statusEl.innerText = `Error: ${err.message} / é”™è¯¯: ${err.message}`;
                    statusEl.classList.add('error');
                }
                const positionData = document.getElementById('positionData');
                if (positionData) positionData.style.display = 'none';
            } finally {
                isRefreshingPosition = false;
            }
        }

        async function loadStatus() {
            try {
                // Get Hyperliquid-specific status / è·å– Hyperliquid ç‰¹å®šçŠ¶æ€
                const res = await diagnosticFetch('/api/hyperliquid/status');
                const data = await res.json();
                
                if (data.error) {
                    showMessage(controlMessage, data.error, true);
                    return;
                }
                
                // Note: Hyperliquid status doesn't include strategy config, so we keep defaults
                // æ³¨æ„ï¼šHyperliquid çŠ¶æ€ä¸åŒ…å«ç­–ç•¥é…ç½®ï¼Œå› æ­¤æˆ‘ä»¬ä¿æŒé»˜è®¤å€¼
                document.getElementById('quantityInput').value = data.quantity ?? 0.1;
                document.getElementById('leverageInput').value = data.leverage ?? 5;
                currentEvalSymbol = normalizeSymbol(data.symbol);

                const pairSelect = document.getElementById('pairSelect');
                if (pairSelect && data.symbol) {
                    for (const option of pairSelect.options) {
                        if (option.value.toUpperCase() === data.symbol.toUpperCase()) {
                            pairSelect.value = option.value;
                            break;
                        }
                    }
                }
            } catch (err) {
                showMessage(controlMessage, `Failed to load status: ${err.message}`, true);
            }
        }

        async function updateConfig() {
            try {
                const payload = {
                    spread: parseFloat(document.getElementById('spreadInput').value || '0'),
                    quantity: parseFloat(document.getElementById('quantityInput').value || '0'),
                    strategy_type: 'fixed_spread',
                    strategy_id: 'default',
                };
                // Use Hyperliquid-specific config endpoint / ä½¿ç”¨ Hyperliquid ç‰¹å®šé…ç½®ç«¯ç‚¹
                const res = await diagnosticFetch('/api/hyperliquid/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                const data = await res.json();
                if (data.error) throw new Error(data.error);
                showMessage(controlMessage, 'Strategy config updated. / ç­–ç•¥é…ç½®å·²æ›´æ–°ã€‚');
            } catch (err) {
                showMessage(controlMessage, err.message || 'Failed to update config / æ›´æ–°é…ç½®å¤±è´¥', true);
            }
        }

        async function updateLeverage() {
            try {
                const leverage = parseInt(document.getElementById('leverageInput').value || '1', 10);
                if (isNaN(leverage) || leverage < 1 || leverage > 125) {
                    showMessage(controlMessage, 'Invalid leverage value. Must be between 1 and 125. / æ— æ•ˆçš„æ æ†å€¼ã€‚å¿…é¡»åœ¨ 1 åˆ° 125 ä¹‹é—´ã€‚', true);
                    return;
                }
                
                // Use Hyperliquid-specific leverage endpoint / ä½¿ç”¨ Hyperliquid ç‰¹å®šæ æ†ç«¯ç‚¹
                const res = await diagnosticFetch('/api/hyperliquid/leverage', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(leverage),
                });
                const data = await res.json();
                if (data.error) throw new Error(data.error);
                
                // Use message from response if available, otherwise construct it
                // å¦‚æœå“åº”ä¸­æœ‰æ¶ˆæ¯åˆ™ä½¿ç”¨ï¼Œå¦åˆ™æ„é€ æ¶ˆæ¯
                const message = data.message || `Leverage updated to ${data.leverage || leverage}x / æ æ†å·²æ›´æ–°è‡³ ${data.leverage || leverage}x`;
                showMessage(controlMessage, message);
            } catch (err) {
                showMessage(controlMessage, err.message || 'Failed to update leverage / æ›´æ–°æ æ†å¤±è´¥', true);
            }
        }

        // Price update interval (30 seconds) - balanced to avoid excessive API calls while keeping prices fresh
        // ä»·æ ¼æ›´æ–°é—´éš”ï¼ˆ30ç§’ï¼‰- å¹³è¡¡é¿å…è¿‡å¤š API è°ƒç”¨ï¼ŒåŒæ—¶ä¿æŒä»·æ ¼æœ€æ–°
        const PRICE_UPDATE_INTERVAL = 30000; // 30 seconds / 30 ç§’
        let pairPrices = {}; // Cache for pair prices / äº¤æ˜“å¯¹ä»·æ ¼ç¼“å­˜
        
        // Update prices for all trading pairs in the dropdown / æ›´æ–°ä¸‹æ‹‰åˆ—è¡¨ä¸­æ‰€æœ‰äº¤æ˜“å¯¹çš„ä»·æ ¼
        async function updateAllPairPrices() {
            try {
                const pairSelect = document.getElementById('pairSelect');
                if (!pairSelect) return;
                
                // Get all symbols from options / ä»é€‰é¡¹ä¸­è·å–æ‰€æœ‰äº¤æ˜“å¯¹
                const symbols = Array.from(pairSelect.options).map(opt => opt.value);
                if (symbols.length === 0) return;
                
                // Fetch prices for all symbols at once / ä¸€æ¬¡æ€§è·å–æ‰€æœ‰äº¤æ˜“å¯¹çš„ä»·æ ¼
                const symbolsParam = symbols.map(s => encodeURIComponent(s)).join(',');
                const res = await diagnosticFetch(`/api/hyperliquid/prices?symbols=${symbolsParam}`);
                const data = await res.json();
                
                if (data.ok && data.prices) {
                    // Update cache / æ›´æ–°ç¼“å­˜
                    pairPrices = { ...pairPrices, ...data.prices };
                    
                    // Update option text with prices / ä½¿ç”¨ä»·æ ¼æ›´æ–°é€‰é¡¹æ–‡æœ¬
                    Array.from(pairSelect.options).forEach(option => {
                        const symbol = option.value;
                        const baseSymbol = symbol.split('/')[0]; // Extract base symbol (e.g., "ETH" from "ETH/USDC:USDC")
                        const price = data.prices[symbol];
                        
                        if (price !== null && price !== undefined && !isNaN(price)) {
                            option.textContent = `${symbol} ($${price.toFixed(2)})`;
                            // Store price in cache / å°†ä»·æ ¼å­˜å‚¨åœ¨ç¼“å­˜ä¸­
                            pairPrices[symbol] = price;
                        } else {
                            // If price not available, show cached price or "--" / å¦‚æœä»·æ ¼ä¸å¯ç”¨ï¼Œæ˜¾ç¤ºç¼“å­˜ä»·æ ¼æˆ– "--"
                            const cachedPrice = pairPrices[symbol];
                            if (cachedPrice !== null && cachedPrice !== undefined) {
                                option.textContent = `${symbol} ($${cachedPrice.toFixed(2)})`;
                            } else {
                                option.textContent = `${symbol} (--)`;
                            }
                        }
                    });
                }
            } catch (err) {
                console.warn('Failed to update pair prices / æ›´æ–°äº¤æ˜“å¯¹ä»·æ ¼å¤±è´¥:', err);
                // On error, keep existing prices in options / å‡ºé”™æ—¶ï¼Œä¿æŒé€‰é¡¹ä¸­çš„ç°æœ‰ä»·æ ¼
            }
        }
        
        // Get price for a specific symbol (from cache or fetch) / è·å–ç‰¹å®šäº¤æ˜“å¯¹çš„ä»·æ ¼ï¼ˆä»ç¼“å­˜æˆ–è·å–ï¼‰
        async function getPairPrice(symbol) {
            // Check cache first / å…ˆæ£€æŸ¥ç¼“å­˜
            if (pairPrices[symbol] !== null && pairPrices[symbol] !== undefined) {
                return pairPrices[symbol];
            }
            
            // If not in cache, fetch it / å¦‚æœä¸åœ¨ç¼“å­˜ä¸­ï¼Œè·å–å®ƒ
            try {
                const symbolsParam = encodeURIComponent(symbol);
                const res = await diagnosticFetch(`/api/hyperliquid/prices?symbols=${symbolsParam}`);
                const data = await res.json();
                
                if (data.ok && data.prices && data.prices[symbol] !== null && data.prices[symbol] !== undefined) {
                    pairPrices[symbol] = data.prices[symbol];
                    return data.prices[symbol];
                }
            } catch (err) {
                console.warn(`Failed to fetch price for ${symbol} / è·å– ${symbol} ä»·æ ¼å¤±è´¥:`, err);
            }
            
            return null;
        }

        async function switchPair() {
            try {
                const symbol = document.getElementById('pairSelect').value;
                
                // Immediately update price for the selected pair / ç«‹å³æ›´æ–°é€‰ä¸­äº¤æ˜“å¯¹çš„ä»·æ ¼
                await getPairPrice(symbol);
                
                // Use Hyperliquid-specific pair endpoint / ä½¿ç”¨ Hyperliquid ç‰¹å®šäº¤æ˜“å¯¹ç«¯ç‚¹
                const res = await diagnosticFetch('/api/hyperliquid/pair', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ symbol }),
                });
                const data = await res.json();
                
                // Check for error
                if (data.error) {
                    throw new Error(data.error);
                }
                
                // Update symbol
                currentEvalSymbol = normalizeSymbol(symbol);
                
                // Show success message, with warning if connection is needed
                if (data.warning) {
                    showMessage(controlMessage, `Switched to ${symbol} / å·²åˆ‡æ¢åˆ° ${symbol}. ${data.warning}`, false);
                } else {
                    showMessage(controlMessage, `Switched to ${symbol} / å·²åˆ‡æ¢åˆ° ${symbol}`);
                }
                
                // Refresh connection status to show new pair price / åˆ·æ–°è¿æ¥çŠ¶æ€ä»¥æ˜¾ç¤ºæ–°äº¤æ˜“å¯¹ä»·æ ¼
                checkConnection();
                
                // Only refresh if connected
                if (data.status === 'updated' && !data.warning) {
                    loadStatus();
                    refreshPosition();
                }
            } catch (err) {
                showMessage(controlMessage, err.message || 'Failed to switch pair / åˆ‡æ¢äº¤æ˜“å¯¹å¤±è´¥', true);
            }
        }

        function getEvaluationSymbol() {
            const select = document.getElementById('pairSelect');
            const raw = select && select.value ? select.value : currentEvalSymbol;
            return normalizeSymbol(raw);
        }

        function formatPercent(value, decimals = 1) {
            if (value === null || value === undefined || isNaN(value)) return '--';
            return `${(value * 100).toFixed(decimals)}%`;
        }

        function formatNumber(value, decimals = 2) {
            if (value === null || value === undefined || isNaN(value)) return '--';
            return Number(value).toFixed(decimals);
        }

        function formatCurrency(value) {
            if (value === null || value === undefined || isNaN(value)) return '--';
            return `$${Number(value).toFixed(2)}`;
        }

        // Progress display functions / è¿›åº¦æ˜¾ç¤ºå‡½æ•° (AC-11)
        const STEP_NAMES = [
            { en: 'Collecting Data', zh: 'æ”¶é›†æ•°æ®', icon: 'ğŸ“Š' },
            { en: 'Building Prompt', zh: 'æ•´ç† Prompt', icon: 'ğŸ“' },
            { en: 'Inferring', zh: 'æ¨ç†ä¸­', icon: 'ğŸ§ ' },
            { en: 'Parsing & Validating', zh: 'è§£æå¹¶éªŒè¯', icon: 'ğŸ”' },
            { en: 'Simulating', zh: 'æ¨¡æ‹Ÿä¸­', icon: 'ğŸ²' },
            { en: 'Scoring', zh: 'æ‰“åˆ†ä¸­', icon: 'ğŸ“ˆ' },
        ];

        function updateProgressDisplay() {
            const progressPanel = document.getElementById('evaluationProgressPanel');
            if (!progressPanel) return;

            if (!evaluationState.loading) {
                progressPanel.style.display = 'none';
                if (evaluationState.elapsedInterval) {
                    clearInterval(evaluationState.elapsedInterval);
                    evaluationState.elapsedInterval = null;
                }
                return;
            }

            progressPanel.style.display = 'block';

            // Update elapsed time / æ›´æ–°å·²ç”¨æ—¶é—´
            if (evaluationState.startTime) {
                const elapsed = Math.floor((Date.now() - evaluationState.startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                const elapsedText = document.getElementById('elapsedTimeText');
                if (elapsedText) {
                    elapsedText.innerText = `Elapsed: ${minutes}m ${seconds}s / å·²ç”¨æ—¶é—´: ${minutes}åˆ† ${seconds}ç§’`;
                }
            }

            // Update overall progress / æ›´æ–°æ€»ä½“è¿›åº¦
            const completedCount = Object.values(evaluationState.providerStatus).filter(s => s.status === 'completed' || s.status === 'failed').length;
            const totalCount = evaluationState.providers.length;
            const progressPercent = totalCount > 0 ? (completedCount / totalCount) * 100 : 0;

            const overallProgressText = document.getElementById('overallProgressText');
            const overallProgressPercent = document.getElementById('overallProgressPercent');
            const overallProgressBar = document.getElementById('overallProgressBar');
            const overallStatusText = document.getElementById('overallStatusText');
            const overallStatusIcon = document.getElementById('overallStatusIcon');

            if (overallProgressText) {
                overallProgressText.innerText = `${completedCount} / ${totalCount} providers completed / ${completedCount} / ${totalCount} ä¸ªæä¾›å•†å·²å®Œæˆ`;
            }
            if (overallProgressPercent) {
                overallProgressPercent.innerText = `${Math.round(progressPercent)}%`;
            }
            if (overallProgressBar) {
                overallProgressBar.style.width = `${progressPercent}%`;
            }

            if (completedCount === totalCount && totalCount > 0) {
                const hasFailed = Object.values(evaluationState.providerStatus).some(s => s.status === 'failed');
                if (hasFailed && completedCount === totalCount) {
                    if (overallStatusText) overallStatusText.innerText = 'Evaluation Failed / è¯„ä¼°å¤±è´¥';
                    if (overallStatusIcon) overallStatusIcon.innerText = 'âœ—';
                } else {
                    if (overallStatusText) overallStatusText.innerText = 'Evaluation Completed / è¯„ä¼°å·²å®Œæˆ';
                    if (overallStatusIcon) overallStatusIcon.innerText = 'âœ“';
                }
            } else {
                if (overallStatusText) overallStatusText.innerText = 'Evaluation in Progress / è¯„ä¼°è¿›è¡Œä¸­';
                if (overallStatusIcon) overallStatusIcon.innerText = 'â³';
            }

            // Update provider status list / æ›´æ–°æä¾›å•†çŠ¶æ€åˆ—è¡¨
            const providerList = document.getElementById('providerStatusList');
            if (providerList) {
                providerList.innerHTML = evaluationState.providers.map(providerName => {
                    const status = evaluationState.providerStatus[providerName] || { status: 'pending', step: 0, stepProgress: 0 };
                    const isActive = status.status === 'in_progress';
                    const isCompleted = status.status === 'completed';
                    const isFailed = status.status === 'failed';

                    let statusClass = 'provider-status-item';
                    if (isActive) statusClass += ' active';
                    else if (isCompleted) statusClass += ' completed';
                    else if (isFailed) statusClass += ' failed';

                    let stepIndicator = '';
                    let statusText = '';
                    let progressBar = '';
                    let elapsedTime = '';

                    if (status.status === 'completed') {
                        stepIndicator = `<span class="step-indicator completed">âœ“ Completed / å·²å®Œæˆ</span>`;
                        statusText = 'Completed / å·²å®Œæˆ';
                        if (status.completedAt) {
                            const elapsed = Math.floor((status.completedAt - evaluationState.startTime) / 1000);
                            elapsedTime = `<div style="font-size:11px; color:#6b7280; margin-top:4px;">Completed in ${elapsed}s / å®Œæˆäº ${elapsed}ç§’</div>`;
                        }
                    } else if (status.status === 'failed') {
                        stepIndicator = `<span class="step-indicator failed">âœ— Failed / å¤±è´¥</span>`;
                        statusText = status.error || 'Failed / å¤±è´¥';
                        if (status.failedAt) {
                            const elapsed = Math.floor((status.failedAt - evaluationState.startTime) / 1000);
                            elapsedTime = `<div style="font-size:11px; color:#6b7280; margin-top:4px;">Failed in ${elapsed}s / å¤±è´¥äº ${elapsed}ç§’</div>`;
                        }
                    } else if (status.status === 'in_progress') {
                        const stepInfo = STEP_NAMES[status.step] || STEP_NAMES[0];
                        stepIndicator = `<span class="step-indicator active">Step ${status.step + 1}/6: ${stepInfo.en} / æ­¥éª¤ ${status.step + 1}/6: ${stepInfo.zh}</span>`;
                        statusText = `${stepInfo.icon} ${stepInfo.en}... / ${stepInfo.zh}...`;

                        // Show progress bar for simulating step / ä¸ºæ¨¡æ‹Ÿæ­¥éª¤æ˜¾ç¤ºè¿›åº¦æ¡
                        if (status.step === 4) { // Simulating step
                            const simProgress = status.stepProgress || 0;
                            progressBar = `
                                <div style="margin-top:8px;">
                                    <div style="font-size:11px; color:#6b7280; margin-bottom:2px;">
                                        Simulating: ${simProgress}/500 steps (${Math.round(simProgress / 5)}%) / æ¨¡æ‹Ÿä¸­: ${simProgress}/500 æ­¥ (${Math.round(simProgress / 5)}%)
                                    </div>
                                    <div class="individual-progress-bar">
                                        <div class="individual-progress-bar-fill" style="width:${(simProgress / 500) * 100}%;"></div>
                                    </div>
                                </div>
                            `;
                        }
                    } else {
                        stepIndicator = `<span class="step-indicator">â¸ Pending / ç­‰å¾…ä¸­</span>`;
                        statusText = 'Waiting... / ç­‰å¾…ä¸­...';
                    }

                    return `
                        <div class="${statusClass}">
                            <div style="display:flex; justify-content:space-between; align-items:center;">
                                <div style="font-weight:bold; font-size:13px;">${providerName}</div>
                                ${stepIndicator}
                            </div>
                            <div style="font-size:12px; color:#6b7280; margin-top:4px;">${statusText}</div>
                            ${progressBar}
                            ${elapsedTime}
                        </div>
                    `;
                }).join('');
            }
        }

        function simulateProgress() {
            // Simulate progress for each provider / ä¸ºæ¯ä¸ªæä¾›å•†æ¨¡æ‹Ÿè¿›åº¦
            evaluationState.providers.forEach((providerName, index) => {
                if (!evaluationState.providerStatus[providerName]) {
                    evaluationState.providerStatus[providerName] = { status: 'pending', step: 0, stepProgress: 0 };
                }

                const status = evaluationState.providerStatus[providerName];
                if (status.status === 'pending' || status.status === 'in_progress') {
                    // Simulate step progression / æ¨¡æ‹Ÿæ­¥éª¤è¿›å±•
                    const delay = index * 2000; // Stagger providers / é”™å¼€æä¾›å•†
                    setTimeout(() => {
                        status.status = 'in_progress';
                        updateProgressDisplay();

                        // Simulate each step / æ¨¡æ‹Ÿæ¯ä¸ªæ­¥éª¤
                        STEP_NAMES.forEach((_, stepIndex) => {
                            setTimeout(() => {
                                status.step = stepIndex;
                                if (stepIndex === 4) { // Simulating step
                                    // Simulate simulation progress / æ¨¡æ‹Ÿæ¨¡æ‹Ÿè¿›åº¦
                                    let simProgress = 0;
                                    const simInterval = setInterval(() => {
                                        simProgress += 50;
                                        status.stepProgress = Math.min(simProgress, 500);
                                        updateProgressDisplay();
                                        if (simProgress >= 500) {
                                            clearInterval(simInterval);
                                        }
                                    }, 200);
                                    setTimeout(() => clearInterval(simInterval), 10000);
                                }
                                updateProgressDisplay();
                            }, stepIndex * 1500 + delay);
                        });

                        // Mark as completed after all steps / æ‰€æœ‰æ­¥éª¤åæ ‡è®°ä¸ºå®Œæˆ
                        setTimeout(() => {
                            status.status = 'completed';
                            status.completedAt = Date.now();
                            updateProgressDisplay();
                        }, STEP_NAMES.length * 1500 + delay + 1000);
                    }, delay);
                }
            });
        }

        function updateEvaluationUI() {
            const statusEl = document.getElementById('evaluationStatusText');
            const runBtn = document.getElementById('runEvaluationBtn');
            const errorBox = document.getElementById('evaluationErrorBox');
            const consensusCard = document.getElementById('evaluationConsensusCard');
            const resultsWrapper = document.getElementById('evaluationResultsWrapper');
            const resultsBody = document.getElementById('evaluationResultsBody');
            const lastRunEl = document.getElementById('evaluationLastRun');

            if (runBtn) runBtn.disabled = evaluationState.loading;
            if (evaluationState.loading) {
                statusEl.innerText = 'Running evaluation... Please wait. / æ­£åœ¨è¿è¡Œè¯„ä¼°... è¯·ç¨å€™ã€‚';
            } else if (evaluationState.lastRunAt) {
                statusEl.innerText = `Last run: ${evaluationState.lastRunSymbol} @ ${new Date(evaluationState.lastRunAt).toLocaleTimeString()} / ä¸Šæ¬¡è¿è¡Œ: ${evaluationState.lastRunSymbol} @ ${new Date(evaluationState.lastRunAt).toLocaleTimeString()}`;
            } else {
                statusEl.innerText = 'Ready. / å°±ç»ªã€‚';
            }

            if (evaluationState.lastError) {
                errorBox.style.display = 'block';
                errorBox.innerText = evaluationState.lastError;
            } else {
                errorBox.style.display = 'none';
            }

            // Update progress display / æ›´æ–°è¿›åº¦æ˜¾ç¤º
            updateProgressDisplay();

            if (consensusCard) {
                const aggregated = evaluationState.aggregated;
                if (aggregated && aggregated.consensus_proposal && aggregated.strategy_consensus) {
                    const proposal = aggregated.consensus_proposal;
                    consensusCard.style.display = 'block';
                    document.getElementById('evaluationConsensusStrategy').innerText = proposal.recommended_strategy || '--';
                    document.getElementById('evaluationConsensusParams').innerText =
                        `${formatPercent(proposal.spread || 0, 2)} Â· Qty ${formatNumber(proposal.quantity || 0, 3)} Â· Lev ${formatNumber(proposal.leverage || 0, 1)}x`;
                    // Display reasoning, or show default message if empty
                    // æ˜¾ç¤ºæ¨ç†ï¼Œå¦‚æœä¸ºç©ºåˆ™æ˜¾ç¤ºé»˜è®¤æ¶ˆæ¯
                    const reasoning = proposal.reasoning && proposal.reasoning.trim() 
                        ? proposal.reasoning 
                        : 'Consensus reasoning unavailable. / å…±è¯†æ¨ç†ä¸å¯ç”¨ã€‚';
                    document.getElementById('evaluationConsensusReasoning').innerText = reasoning;
                    document.getElementById('evaluationConsensusStats').innerText =
                        `Avg PnL ${formatCurrency(aggregated.avg_pnl || 0)} Â· Avg Sharpe ${formatNumber(aggregated.avg_sharpe || 0, 2)} Â· Avg Win ${formatPercent(aggregated.avg_win_rate || 0, 1)}`;
                } else {
                    consensusCard.style.display = 'none';
                }
            }

            if (resultsWrapper) {
                if (evaluationState.results.length > 0) {
                    resultsWrapper.style.display = 'block';
                    lastRunEl.innerText = evaluationState.lastRunAt
                        ? `Updated ${new Date(evaluationState.lastRunAt).toLocaleTimeString()} / æ›´æ–°äº ${new Date(evaluationState.lastRunAt).toLocaleTimeString()}`
                        : '';
                    const rows = evaluationState.results.map((result) => {
                        const proposal = result.proposal || {};
                        const simulation = result.simulation || {};
                        const disabledApply = !proposal.parse_success ? 'disabled' : '';
                        const providerSafe = (result.provider_name || '').replace(/"/g, '&quot;');
                        const highlight = result.rank === 1 ? 'style="background:#fef3c7;"' : '';
                        return `
                            <tr ${highlight}>
                                <td>${result.rank ?? '--'}</td>
                                <td>${result.provider_name || '--'}</td>
                                <td>${proposal.recommended_strategy || '--'}</td>
                                <td>${formatPercent(proposal.spread || 0, 2)}</td>
                                <td>${formatNumber(proposal.quantity || 0, 3)}</td>
                                <td>${formatNumber(proposal.leverage || 0, 1)}x</td>
                                <td>${formatPercent(proposal.confidence || 0, 1)}</td>
                                <td>${formatCurrency(simulation.realized_pnl)}</td>
                                <td>${formatNumber(simulation.sharpe_ratio || 0, 2)}</td>
                                <td>${formatPercent(simulation.win_rate || 0, 1)}</td>
                                <td>${formatNumber(result.score || 0, 1)}</td>
                                <td><button class="btn btn-secondary" style="font-size:11px;" ${disabledApply}
                                    onclick="applyEvaluation('individual', '${providerSafe}')">Apply</button></td>
                            </tr>`;
                    }).join('');
                    resultsBody.innerHTML = rows;
                } else {
                    resultsWrapper.style.display = 'none';
                    lastRunEl.innerText = '';
                }
            }
        }

        async function runEvaluation() {
            if (evaluationState.loading) return;
            evaluationState.loading = true;
            evaluationState.lastError = null;
            evaluationState.startTime = Date.now();
            evaluationState.providerStatus = {};
            
            // Initialize provider status / åˆå§‹åŒ–æä¾›å•†çŠ¶æ€
            evaluationState.providers.forEach(name => {
                evaluationState.providerStatus[name] = { status: 'pending', step: 0, stepProgress: 0 };
            });

            // Start elapsed time counter / å¯åŠ¨å·²ç”¨æ—¶é—´è®¡æ•°å™¨
            if (evaluationState.elapsedInterval) clearInterval(evaluationState.elapsedInterval);
            evaluationState.elapsedInterval = setInterval(() => {
                updateProgressDisplay();
            }, 1000);

            updateEvaluationUI();
            simulateProgress(); // Start progress simulation / å¯åŠ¨è¿›åº¦æ¨¡æ‹Ÿ

            try {
                const res = await diagnosticFetch('/api/evaluation/run', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        symbol: getEvaluationSymbol(),
                        exchange: 'hyperliquid',  // Always use hyperliquid exchange
                        simulation_steps: 500
                    }),
                });
                const data = await res.json();
                if (data.error) throw new Error(data.error);
                
                // Mark all providers as completed / æ ‡è®°æ‰€æœ‰æä¾›å•†ä¸ºå·²å®Œæˆ
                evaluationState.providers.forEach(name => {
                    if (evaluationState.providerStatus[name].status !== 'failed') {
                        evaluationState.providerStatus[name].status = 'completed';
                        evaluationState.providerStatus[name].completedAt = Date.now();
                    }
                });

                evaluationState.results = data.individual_results || [];
                evaluationState.aggregated = data.aggregated || null;
                evaluationState.lastRunSymbol = data.symbol || getEvaluationSymbol();
                evaluationState.lastRunAt = new Date().toISOString();
            } catch (err) {
                // Mark all providers as failed / æ ‡è®°æ‰€æœ‰æä¾›å•†ä¸ºå¤±è´¥
                evaluationState.providers.forEach(name => {
                    evaluationState.providerStatus[name].status = 'failed';
                    evaluationState.providerStatus[name].failedAt = Date.now();
                    evaluationState.providerStatus[name].error = err.message;
                });
                evaluationState.lastError = err.message || 'Failed to run evaluation / è¿è¡Œè¯„ä¼°å¤±è´¥';
            } finally {
                evaluationState.loading = false;
                updateEvaluationUI();
                if (evaluationState.elapsedInterval) {
                    clearInterval(evaluationState.elapsedInterval);
                    evaluationState.elapsedInterval = null;
                }
            }
        }

        async function applyEvaluation(source, providerName = null) {
            try {
                const payload = { 
                    source,
                    exchange: 'hyperliquid'  // Always use hyperliquid exchange
                };
                if (providerName) payload.provider_name = providerName;
                const res = await diagnosticFetch('/api/evaluation/apply', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                const data = await res.json();
                if (data.error) throw new Error(data.error);
                showMessage(controlMessage, 'Applied evaluation proposal. / å·²åº”ç”¨è¯„ä¼°å»ºè®®ã€‚');
                loadStatus();
            } catch (err) {
                showMessage(controlMessage, err.message || 'Failed to apply proposal / åº”ç”¨å»ºè®®å¤±è´¥', true);
            }
        }

        async function startBotWithLLMSuggestion() {
            try {
                await applyEvaluation('consensus');
                const res = await diagnosticFetch('/api/control?action=start', {
                    method: 'POST',
                });
                const data = await res.json();
                if (data.error) throw new Error(data.error);
                showMessage(controlMessage, 'âœ… Bot started with LLM suggestion! / Bot å·²ä½¿ç”¨ LLM å»ºè®®å¯åŠ¨ï¼');
                setTimeout(refreshOrders, 1000);
            } catch (err) {
                showMessage(controlMessage, err.message || 'Failed to start bot / å¯åŠ¨ Bot å¤±è´¥', true);
            }
        }

        async function refreshOrders() {
            // Prevent duplicate requests / é˜²æ­¢é‡å¤è¯·æ±‚
            if (isRefreshingOrders) return;
            isRefreshingOrders = true;
            
            try {
                const statusEl = document.getElementById('ordersStatusText');
                const tableWrapper = document.getElementById('ordersTableWrapper');
                const tableBody = document.getElementById('ordersTableBody');
                const emptyMessage = document.getElementById('ordersEmptyMessage');
                
                if (statusEl) {
                    statusEl.innerText = 'Loading orders... / æ­£åœ¨åŠ è½½è®¢å•...';
                    statusEl.classList.remove('error');
                }
                
                // Get Hyperliquid-specific status / è·å– Hyperliquid ç‰¹å®šçŠ¶æ€
                const res = await diagnosticFetch('/api/hyperliquid/status');
                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                }
                const data = await res.json();
                
                if (data.error) {
                    if (tableWrapper) tableWrapper.style.display = 'none';
                    if (emptyMessage) emptyMessage.style.display = 'block';
                    if (statusEl) {
                        statusEl.innerText = data.error;
                        statusEl.classList.add('error');
                    }
                    return;
                }
                
                const orders = data.orders || [];
                
                if (orders.length === 0) {
                    if (tableWrapper) tableWrapper.style.display = 'none';
                    if (emptyMessage) emptyMessage.style.display = 'block';
                    if (statusEl) {
                        statusEl.innerText = 'No active orders / æ— æ´»è·ƒè®¢å•';
                        statusEl.classList.remove('error');
                    }
                } else {
                    if (tableWrapper) tableWrapper.style.display = 'block';
                    if (emptyMessage) emptyMessage.style.display = 'none';
                    if (statusEl) {
                        statusEl.innerText = `Found ${orders.length} active order(s) / æ‰¾åˆ° ${orders.length} ä¸ªæ´»è·ƒè®¢å•`;
                        statusEl.classList.remove('error');
                    }
                    
                    if (tableBody) {
                        const rows = orders.map(order => {
                            const orderId = order.id || order.orderId || order.oid || '--';
                            const side = order.side || (order.sz > 0 ? 'BUY' : 'SELL') || '--';
                            const price = formatNumber(order.price || order.limitPx || 0, 4);
                            const quantity = formatNumber(Math.abs(order.amount || order.sz || order.quantity || 0), 4);
                            const status = order.status || order.status || 'open';
                            const timestamp = order.timestamp ? new Date(order.timestamp).toLocaleTimeString() : '--';
                            
                            const sideColor = side.toLowerCase() === 'buy' ? '#22c55e' : '#ef4444';
                            const safeOrderId = String(orderId).replace(/'/g, "\\'");
                            
                            return `
                                <tr>
                                    <td style="font-family:monospace; font-size:11px;">${String(orderId).substring(0, 20)}${String(orderId).length > 20 ? '...' : ''}</td>
                                    <td><span style="color:${sideColor}; font-weight:bold;">${side.toUpperCase()}</span></td>
                                    <td>${price}</td>
                                    <td>${quantity}</td>
                                    <td><span style="padding:2px 6px; border-radius:4px; background:#e5e7eb; font-size:11px;">${status}</span></td>
                                    <td style="font-size:11px; color:#6b7280;">${timestamp}</td>
                                    <td><button class="btn btn-danger" style="font-size:11px; padding:4px 8px;" onclick="cancelOrder('${safeOrderId}')">Cancel</button></td>
                                </tr>`;
                        }).join('');
                        
                        tableBody.innerHTML = rows;
                    }
                }
            } catch (err) {
                const statusEl = document.getElementById('ordersStatusText');
                if (statusEl) {
                    statusEl.innerText = `Error loading orders: ${err.message} / åŠ è½½è®¢å•é”™è¯¯: ${err.message}`;
                    statusEl.classList.add('error');
                }
                const tableWrapper = document.getElementById('ordersTableWrapper');
                const emptyMessage = document.getElementById('ordersEmptyMessage');
                if (tableWrapper) tableWrapper.style.display = 'none';
                if (emptyMessage) emptyMessage.style.display = 'block';
            } finally {
                isRefreshingOrders = false;
            }
        }

        async function cancelOrder(orderId) {
            try {
                if (!orderId || orderId === '--') {
                    showMessage(controlMessage, 'Invalid order ID / æ— æ•ˆçš„è®¢å• ID', true);
                    return;
                }
                
                // Use Hyperliquid-specific cancel order endpoint / ä½¿ç”¨ Hyperliquid ç‰¹å®šå–æ¶ˆè®¢å•ç«¯ç‚¹
                const res = await diagnosticFetch('/api/hyperliquid/cancel-order', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(orderId),
                });
                const data = await res.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                showMessage(controlMessage, data.message || `Order ${orderId} canceled / è®¢å• ${orderId} å·²å–æ¶ˆ`);
                
                // Refresh orders after cancellation / å–æ¶ˆååˆ·æ–°è®¢å•
                setTimeout(refreshOrders, 500);
            } catch (err) {
                showMessage(controlMessage, err.message || 'Failed to cancel order / å–æ¶ˆè®¢å•å¤±è´¥', true);
            }
        }

        // Auto-refresh - Track intervals for cleanup
        // è‡ªåŠ¨åˆ·æ–° - è·Ÿè¸ªé—´éš”ä»¥ä¾¿æ¸…ç†
        let ordersRefreshInterval = null;
        let positionRefreshInterval = null;
        let connectionRefreshInterval = null;
        
        function startAutoRefresh() {
            if (ordersRefreshInterval) clearInterval(ordersRefreshInterval);
            if (positionRefreshInterval) clearInterval(positionRefreshInterval);
            if (connectionRefreshInterval) clearInterval(connectionRefreshInterval);
            
            // Initial load
            refreshOrders();
            refreshPosition();
            checkConnection();
            
            // Reduced refresh intervals to avoid rate limiting (429 errors)
            // å‡å°‘åˆ·æ–°é—´éš”ä»¥é¿å…é€Ÿç‡é™åˆ¶ï¼ˆ429 é”™è¯¯ï¼‰
            ordersRefreshInterval = setInterval(refreshOrders, 15000);  // 15 seconds (was 3)
            positionRefreshInterval = setInterval(refreshPosition, 20000);  // 20 seconds (was 5)
            connectionRefreshInterval = setInterval(checkConnection, 30000);  // 30 seconds (was 10)
        }

        // Suppress Chrome extension runtime.lastError messages
        // These errors are caused by browser extensions trying to communicate
        // and don't affect page functionality
        // æŠ‘åˆ¶ Chrome æ‰©å±• runtime.lastError æ¶ˆæ¯
        // è¿™äº›é”™è¯¯æ˜¯ç”±æµè§ˆå™¨æ‰©å±•å°è¯•é€šä¿¡å¼•èµ·çš„ï¼Œä¸å½±å“é¡µé¢åŠŸèƒ½
        const originalError = console.error;
        console.error = function(...args) {
            // Filter out Chrome extension runtime.lastError messages
            // è¿‡æ»¤æ‰ Chrome æ‰©å±• runtime.lastError æ¶ˆæ¯
            if (args.length > 0 && typeof args[0] === 'string' && 
                (args[0].includes('runtime.lastError') || 
                 args[0].includes('Could not establish connection') ||
                 args[0].includes('Receiving end does not exist'))) {
                return; // Suppress this error
            }
            originalError.apply(console, args);
        };

        document.addEventListener('DOMContentLoaded', () => {
            loadStatus();
            updateEvaluationUI();
            checkConnection();
            refreshPosition();
            refreshOrders();
            startAutoRefresh();
            
            // Initialize Error History Panel / åˆå§‹åŒ–é”™è¯¯å†å²é¢æ¿
            if (window.ErrorHistoryPanel) {
                new ErrorHistoryPanel('errorHistoryPanel', {
                    refreshInterval: 30000, // 30 seconds / 30 ç§’
                    autoRefresh: true
                });
            }
            
            // Load initial pair prices in dropdown / åœ¨ä¸‹æ‹‰åˆ—è¡¨ä¸­åŠ è½½åˆå§‹äº¤æ˜“å¯¹ä»·æ ¼
            updateAllPairPrices();
            
            // Set up periodic price updates (balanced frequency to avoid excessive API calls) / è®¾ç½®å®šæœŸä»·æ ¼æ›´æ–°ï¼ˆå¹³è¡¡é¢‘ç‡ä»¥é¿å…è¿‡å¤š API è°ƒç”¨ï¼‰
            setInterval(updateAllPairPrices, PRICE_UPDATE_INTERVAL);
            
            // Also update connection status periodically to refresh selected pair price / å®šæœŸæ›´æ–°è¿æ¥çŠ¶æ€ä»¥åˆ·æ–°é€‰ä¸­äº¤æ˜“å¯¹ä»·æ ¼
            // This is already handled by checkConnection interval, but we ensure it uses the selected pair / è¿™å·²ç»ç”± checkConnection é—´éš”å¤„ç†ï¼Œä½†æˆ‘ä»¬ç¡®ä¿å®ƒä½¿ç”¨é€‰ä¸­çš„äº¤æ˜“å¯¹
        });
    </script>
</body>

</html>




